(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[18],{

/***/ "./node_modules/isemail/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/isemail/lib/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n// Load modules\n\nconst Punycode = __webpack_require__(/*! punycode */ \"./node_modules/node-libs-browser/node_modules/punycode/punycode.js\");\n\n// Declare internals\n\nconst internals = {\n    hasOwn: Object.prototype.hasOwnProperty,\n    indexOf: Array.prototype.indexOf,\n    defaultThreshold: 16,\n    maxIPv6Groups: 8,\n\n    categories: {\n        valid: 1,\n        dnsWarn: 7,\n        rfc5321: 15,\n        cfws: 31,\n        deprecated: 63,\n        rfc5322: 127,\n        error: 255\n    },\n\n    diagnoses: {\n\n        // Address is valid\n\n        valid: 0,\n\n        // Address is valid for SMTP but has unusual elements\n\n        rfc5321TLD: 9,\n        rfc5321TLDNumeric: 10,\n        rfc5321QuotedString: 11,\n        rfc5321AddressLiteral: 12,\n\n        // Address is valid for message, but must be modified for envelope\n\n        cfwsComment: 17,\n        cfwsFWS: 18,\n\n        // Address contains non-ASCII when the allowUnicode option is false\n        // Has to be > internals.defaultThreshold so that it's rejected\n        // without an explicit errorLevel:\n        undesiredNonAscii: 25,\n\n        // Address contains deprecated elements, but may still be valid in some contexts\n\n        deprecatedLocalPart: 33,\n        deprecatedFWS: 34,\n        deprecatedQTEXT: 35,\n        deprecatedQP: 36,\n        deprecatedComment: 37,\n        deprecatedCTEXT: 38,\n        deprecatedIPv6: 39,\n        deprecatedCFWSNearAt: 49,\n\n        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n\n        rfc5322Domain: 65,\n        rfc5322TooLong: 66,\n        rfc5322LocalTooLong: 67,\n        rfc5322DomainTooLong: 68,\n        rfc5322LabelTooLong: 69,\n        rfc5322DomainLiteral: 70,\n        rfc5322DomainLiteralOBSDText: 71,\n        rfc5322IPv6GroupCount: 72,\n        rfc5322IPv62x2xColon: 73,\n        rfc5322IPv6BadCharacter: 74,\n        rfc5322IPv6MaxGroups: 75,\n        rfc5322IPv6ColonStart: 76,\n        rfc5322IPv6ColonEnd: 77,\n\n        // Address is invalid for any purpose\n\n        errExpectingDTEXT: 129,\n        errNoLocalPart: 130,\n        errNoDomain: 131,\n        errConsecutiveDots: 132,\n        errATEXTAfterCFWS: 133,\n        errATEXTAfterQS: 134,\n        errATEXTAfterDomainLiteral: 135,\n        errExpectingQPair: 136,\n        errExpectingATEXT: 137,\n        errExpectingQTEXT: 138,\n        errExpectingCTEXT: 139,\n        errBackslashEnd: 140,\n        errDotStart: 141,\n        errDotEnd: 142,\n        errDomainHyphenStart: 143,\n        errDomainHyphenEnd: 144,\n        errUnclosedQuotedString: 145,\n        errUnclosedComment: 146,\n        errUnclosedDomainLiteral: 147,\n        errFWSCRLFx2: 148,\n        errFWSCRLFEnd: 149,\n        errCRNoLF: 150,\n        errUnknownTLD: 160,\n        errDomainTooShort: 161\n    },\n\n    components: {\n        localpart: 0,\n        domain: 1,\n        literal: 2,\n        contextComment: 3,\n        contextFWS: 4,\n        contextQuotedString: 5,\n        contextQuotedPair: 6\n    }\n};\n\n\ninternals.specials = function () {\n\n    const specials = '()<>[]:;@\\\\,.\"';        // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    for (let i = 0; i < specials.length; ++i) {\n        lookup[specials.codePointAt(i)] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.c0Controls = function () {\n\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    // add C0 control characters\n\n    for (let i = 0; i < 33; ++i) {\n        lookup[i] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.c1Controls = function () {\n\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    // add C1 control characters\n\n    for (let i = 127; i < 160; ++i) {\n        lookup[i] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.regex = {\n    ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipV6: /^[a-fA-F\\d]{0,4}$/\n};\n\ninternals.normalizeSupportsNul = '\\0'.normalize('NFC') === '\\0';\n\n\n// $lab:coverage:off$\ninternals.nulNormalize = function (email) {\n\n    return email.split('\\0').map((part) => part.normalize('NFC')).join('\\0');\n};\n// $lab:coverage:on$\n\n\ninternals.normalize = function (email) {\n\n    // $lab:coverage:off$\n    if (!internals.normalizeSupportsNul && email.indexOf('\\0') >= 0) {\n        return internals.nulNormalize(email);\n    }\n    // $lab:coverage:on$\n\n    return email.normalize('NFC');\n};\n\n\ninternals.checkIpV6 = function (items) {\n\n    return items.every((value) => internals.regex.ipV6.test(value));\n};\n\n\ninternals.validDomain = function (tldAtom, options) {\n\n    if (options.tldBlacklist) {\n        if (Array.isArray(options.tldBlacklist)) {\n            return internals.indexOf.call(options.tldBlacklist, tldAtom) === -1;\n        }\n\n        return !internals.hasOwn.call(options.tldBlacklist, tldAtom);\n    }\n\n    if (Array.isArray(options.tldWhitelist)) {\n        return internals.indexOf.call(options.tldWhitelist, tldAtom) !== -1;\n    }\n\n    return internals.hasOwn.call(options.tldWhitelist, tldAtom);\n};\n\n\n/**\n * Check that an email address conforms to RFCs 5321, 5322, 6530 and others\n *\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\n * more restrictive (comments, white space and obsolete forms are not allowed).\n *\n * @param {string} email The email address to check. See README for specifics.\n * @param {Object} options The (optional) options:\n *   {*} errorLevel Determines the boundary between valid and invalid\n *     addresses.\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n *   {*} allowUnicode Whether to allow non-ASCII characters, defaults to true.\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\n *     for the address to be valid.\n * @param {function(number|boolean)} callback The (optional) callback handler.\n * @return {*}\n */\n\nexports.validate = internals.validate = function (email, options, callback) {\n\n    options = options || {};\n    email = internals.normalize(email);\n\n    // The callback function is deprecated.\n    // $lab:coverage:off$\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n\n    if (typeof callback !== 'function') {\n        callback = null;\n    }\n    // $lab:coverage:on$\n\n    let diagnose;\n    let threshold;\n\n    if (typeof options.errorLevel === 'number') {\n        diagnose = true;\n        threshold = options.errorLevel;\n    }\n    else {\n        diagnose = !!options.errorLevel;\n        threshold = internals.diagnoses.valid;\n    }\n\n    if (options.tldWhitelist) {\n        if (typeof options.tldWhitelist === 'string') {\n            options.tldWhitelist = [options.tldWhitelist];\n        }\n        else if (typeof options.tldWhitelist !== 'object') {\n            throw new TypeError('expected array or object tldWhitelist');\n        }\n    }\n\n    if (options.tldBlacklist) {\n        if (typeof options.tldBlacklist === 'string') {\n            options.tldBlacklist = [options.tldBlacklist];\n        }\n        else if (typeof options.tldBlacklist !== 'object') {\n            throw new TypeError('expected array or object tldBlacklist');\n        }\n    }\n\n    if (options.minDomainAtoms && (options.minDomainAtoms !== ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {\n        throw new TypeError('expected positive integer minDomainAtoms');\n    }\n\n    let maxResult = internals.diagnoses.valid;\n    const updateResult = (value) => {\n\n        if (value > maxResult) {\n            maxResult = value;\n        }\n    };\n\n    const allowUnicode = options.allowUnicode === undefined || !!options.allowUnicode;\n    if (!allowUnicode && /[^\\x00-\\x7f]/.test(email)) {\n        updateResult(internals.diagnoses.undesiredNonAscii);\n    }\n\n    const context = {\n        now: internals.components.localpart,\n        prev: internals.components.localpart,\n        stack: [internals.components.localpart]\n    };\n\n    let prevToken = '';\n\n    const parseData = {\n        local: '',\n        domain: ''\n    };\n    const atomData = {\n        locals: [''],\n        domains: ['']\n    };\n\n    let elementCount = 0;\n    let elementLength = 0;\n    let crlfCount = 0;\n    let charCode;\n\n    let hyphenFlag = false;\n    let assertEnd = false;\n\n    const emailLength = email.length;\n\n    let token;                                      // Token is used outside the loop, must declare similarly\n    for (let i = 0; i < emailLength; i += token.length) {\n        // Utilize codepoints to account for Unicode surrogate pairs\n        token = String.fromCodePoint(email.codePointAt(i));\n\n        switch (context.now) {\n            // Local-part\n            case internals.components.localpart:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   local-part      =   dot-atom / quoted-string / obs-local-part\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   quoted-string   =   [CFWS]\n                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                       [CFWS]\n                //\n                //   obs-local-part  =   word *(\".\" word)\n                //\n                //   word            =   atom / quoted-string\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments are OK at the beginning of an element\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            updateResult(internals.diagnoses.cfwsComment);\n                            // Cannot start a comment in an element, should be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        if (elementLength === 0) {\n                            // Another dot, already?\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            if (assertEnd) {\n                                updateResult(internals.diagnoses.deprecatedLocalPart);\n                            }\n\n                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n                            assertEnd = false;\n                            elementLength = 0;\n                            ++elementCount;\n                            parseData.local += token;\n                            atomData.locals[elementCount] = '';\n                        }\n\n                        break;\n\n                        // Quoted string\n                    case '\"':\n                        if (elementLength === 0) {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n\n                            // Quoted string must be the entire element\n                            assertEnd = true;\n                            context.stack.push(context.now);\n                            context.now = internals.components.contextQuotedString;\n                        }\n                        else {\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, better be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                    case '@':\n                        // At this point we should have a valid local-part\n                        // $lab:coverage:off$\n                        if (context.stack.length !== 1) {\n                            throw new Error('unexpected item on context stack');\n                        }\n                        // $lab:coverage:on$\n\n                        if (parseData.local.length === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errNoLocalPart);\n                        }\n                        else if (elementLength === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errDotEnd);\n                        }\n                        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n                        //    octets\n                        else if (Buffer.byteLength(parseData.local, 'utf8') > 64) {\n                            updateResult(internals.diagnoses.rfc5322LocalTooLong);\n                        }\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n                        //    addr-spec\n                        //\n                        // http://tools.ietf.org/html/rfc2119\n                        // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n                        //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n                        //    and the case carefully weighed before implementing any behavior described with this label.\n                        else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n                        }\n\n                        // Clear everything down for the domain parsing\n                        context.now = internals.components.domain;\n                        context.stack[0] = internals.components.domain;\n                        elementCount = 0;\n                        elementLength = 0;\n                        assertEnd = false; // CFWS can only appear at the end of the element\n                        break;\n\n                        // ATEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n                        if (assertEnd) {\n                            // We have encountered atext where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.contextQuotedString:\n                                    updateResult(internals.diagnoses.errATEXTAfterQS);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n                        else {\n                            context.prev = context.now;\n                            charCode = token.codePointAt(0);\n\n                            // Especially if charCode == 10\n                            if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n\n                                // Fatal error\n                                updateResult(internals.diagnoses.errExpectingATEXT);\n                            }\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n                        }\n                }\n\n                break;\n\n            case internals.components.domain:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain          =   dot-atom / domain-literal / obs-domain\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-domain      =   atom *(\".\" atom)\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n                //\n                //   Domain         = sub-domain *(\".\" sub-domain)\n                //\n                //   address-literal  = \"[\" ( IPv4-address-literal /\n                //                    IPv6-address-literal /\n                //                    General-address-literal ) \"]\"\n                //                    ; See Section 4.1.3\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //      Note: A liberal syntax for the domain portion of addr-spec is\n                //      given here.  However, the domain portion contains addressing\n                //      information specified by and used in other protocols (e.g.,\n                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n                //      incumbent upon implementations to conform to the syntax of\n                //      addresses for the context in which they are used.\n                //\n                // is_email() author's note: it's not clear how to interpret this in\n                // he context of a general email address validator. The conclusion I\n                // have reached is this: \"addressing information\" must comply with\n                // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n                // invisible\" must comply only with RFC 5322.\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            // We can't start a comment mid-element, better be at the end\n                            assertEnd = true;\n                            updateResult(internals.diagnoses.cfwsComment);\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        const punycodeLength = Punycode.encode(atomData.domains[elementCount]).length;\n                        if (elementLength === 0) {\n                            // Another dot, already? Fatal error.\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else if (hyphenFlag) {\n                            // Previous subdomain ended in a hyphen. Fatal error.\n                            updateResult(internals.diagnoses.errDomainHyphenEnd);\n                        }\n                        else if (punycodeLength > 63) {\n                            // RFC 5890 specifies that domain labels that are encoded using the Punycode algorithm\n                            // must adhere to the <= 63 octet requirement.\n                            // This includes string prefixes from the Punycode algorithm.\n                            //\n                            // https://tools.ietf.org/html/rfc5890#section-2.3.2.1\n                            // labels          63 octets or less\n\n                            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n                        }\n\n                        // CFWS is OK again now we're at the beginning of an element (although\n                        // it may be obsolete CFWS)\n                        assertEnd = false;\n                        elementLength = 0;\n                        ++elementCount;\n                        atomData.domains[elementCount] = '';\n                        parseData.domain += token;\n\n                        break;\n\n                        // Domain literal\n                    case '[':\n                        if (parseData.domain.length === 0) {\n                            // Domain literal must be the only component\n                            assertEnd = true;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n                            context.stack.push(context.now);\n                            context.now = internals.components.literal;\n                            parseData.domain += token;\n                            atomData.domains[elementCount] += token;\n                            parseData.literal = '';\n                        }\n                        else {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, so this better be the end\n                            updateResult(internals.diagnoses.cfwsFWS);\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // This must be ATEXT\n                    default:\n                        // RFC 5322 allows any atext...\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n\n                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n                        //   (RFCs 1034 & 1123)\n                        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                        //   sub-domain     = Let-dig [Ldh-str]\n                        //\n                        //   Let-dig        = ALPHA / DIGIT\n                        //\n                        //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n                        //\n                        if (assertEnd) {\n                            // We have encountered ATEXT where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.literal:\n                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n\n                        charCode = token.codePointAt(0);\n                        // Assume this token isn't a hyphen unless we discover it is\n                        hyphenFlag = false;\n\n                        if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n                        else if (token === '-') {\n                            if (elementLength === 0) {\n                                // Hyphens cannot be at the beginning of a subdomain, fatal error\n                                updateResult(internals.diagnoses.errDomainHyphenStart);\n                            }\n\n                            hyphenFlag = true;\n                        }\n                        // Check if it's a neither a number nor a latin/unicode letter\n                        else if (charCode < 48 || (charCode > 122 && charCode < 192) || (charCode > 57 && charCode < 65) || (charCode > 90 && charCode < 97)) {\n                            // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n                            updateResult(internals.diagnoses.rfc5322Domain);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                break;\n\n                // Domain literal\n            case internals.components.literal:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n                switch (token) {\n                    // End of domain literal\n                    case ']':\n                        if (maxResult < internals.categories.deprecated) {\n                            // Could be a valid RFC 5321 address literal, so let's check\n\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                            //   address-literal  = \"[\" ( IPv4-address-literal /\n                            //                    IPv6-address-literal /\n                            //                    General-address-literal ) \"]\"\n                            //                    ; See Section 4.1.3\n                            //\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.3\n                            //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n                            //\n                            //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n                            //\n                            //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n                            //\n                            //   Standardized-tag  = Ldh-str\n                            //                     ; Standardized-tag MUST be specified in a\n                            //                     ; Standards-Track RFC and registered with IANA\n                            //\n                            //   dcontent      = %d33-90 / ; Printable US-ASCII\n                            //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n                            //\n                            //   Snum          = 1*3DIGIT\n                            //                 ; representing a decimal integer\n                            //                 ; value in the range 0 through 255\n                            //\n                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n                            //\n                            //   IPv6-hex      = 1*4HEXDIG\n                            //\n                            //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n                            //\n                            //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *5(\":\" IPv6-hex)]\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 6 groups in addition to the\n                            //                 ; \"::\" may be present.\n                            //\n                            //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n                            //\n                            //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n                            //                 IPv4-address-literal\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 4 groups in addition to the\n                            //                 ; \"::\" and IPv4-address-literal may be present.\n\n                            let index = -1;\n                            let addressLiteral = parseData.literal;\n                            const matchesIP = internals.regex.ipV4.exec(addressLiteral);\n\n                            // Maybe extract IPv4 part from the end of the address-literal\n                            if (matchesIP) {\n                                index = matchesIP.index;\n                                if (index !== 0) {\n                                    // Convert IPv4 part to IPv6 format for futher testing\n                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';\n                                }\n                            }\n\n                            if (index === 0) {\n                                // Nothing there except a valid IPv4 address, so...\n                                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                            }\n                            else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n                                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                            }\n                            else {\n                                const match = addressLiteral.slice(5);\n                                let maxGroups = internals.maxIPv6Groups;\n                                const groups = match.split(':');\n                                index = match.indexOf('::');\n\n                                if (!~index) {\n                                    // Need exactly the right number of groups\n                                    if (groups.length !== maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n                                    }\n                                }\n                                else if (index !== match.lastIndexOf('::')) {\n                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n                                }\n                                else {\n                                    if (index === 0 || index === match.length - 2) {\n                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n                                        ++maxGroups;\n                                    }\n\n                                    if (groups.length > maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n                                    }\n                                    else if (groups.length === maxGroups) {\n                                        // Eliding a single \"::\"\n                                        updateResult(internals.diagnoses.deprecatedIPv6);\n                                    }\n                                }\n\n                                // IPv6 testing strategy\n                                if (match[0] === ':' && match[1] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n                                }\n                                else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n                                }\n                                else if (internals.checkIpV6(groups)) {\n                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                                }\n                                else {\n                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n                                }\n                            }\n                        }\n                        else {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                    case '\\\\':\n                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // DTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                        //   dtext         =   %d33-90 /  ; Printable US-ASCII\n                        //                     %d94-126 / ;  characters not including\n                        //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n                        //\n                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n                        //\n                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n                        //                     %d11 /     ;  characters that do not\n                        //                     %d12 /     ;  include the carriage\n                        //                     %d14-31 /  ;  return, line feed, and\n                        //                     %d127      ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n                        if ((charCode !== 127 && internals.c1Controls(charCode)) || charCode === 0 || token === '[') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingDTEXT);\n                            break;\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        }\n\n                        parseData.literal += token;\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                break;\n\n                // Quoted string\n            case internals.components.contextQuotedString:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                //   quoted-string = [CFWS]\n                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                   [CFWS]\n                //\n                //   qcontent      = qtext / quoted-pair\n                switch (token) {\n                    // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case '\\t':\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n                        //   a structured header field are semantically interpreted as a single\n                        //   space character.\n\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n                        //   semantically \"invisible\" and therefore not part of the\n                        //   quoted-string\n\n                        parseData.local += ' ';\n                        atomData.locals[elementCount] += ' ';\n                        elementLength += Buffer.byteLength(token, 'utf8');\n\n                        updateResult(internals.diagnoses.cfwsFWS);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // End of quoted string\n                    case '\"':\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // QTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   qtext          =   %d33 /             ; Printable US-ASCII\n                        //                      %d35-91 /          ;  characters not including\n                        //                      %d93-126 /         ;  \"\\\" or the quote character\n                        //                      obs-qtext\n                        //\n                        //   obs-qtext      =   obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n                        //                      %d11 /             ;  characters that do not\n                        //                      %d12 /             ;  include the carriage\n                        //                      %d14-31 /          ;  return, line feed, and\n                        //                      %d127              ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        if ((charCode !== 127 && internals.c1Controls(charCode)) || charCode === 0 || charCode === 10) {\n                            updateResult(internals.diagnoses.errExpectingQTEXT);\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedQTEXT);\n                        }\n\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   If the string can be represented as a dot-atom (that is, it contains\n                //   no characters other than atext characters or \".\" surrounded by atext\n                //   characters), then the dot-atom form SHOULD be used and the quoted-\n                //   string form SHOULD NOT be used.\n\n                break;\n                // Quoted pair\n            case internals.components.contextQuotedPair:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.1\n                //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n                //\n                //   VCHAR           =  %d33-126   ; visible (printing) characters\n                //   WSP             =  SP / HTAB  ; white space\n                //\n                //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n                //\n                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n                //                       %d11 /    ;  characters that do not\n                //                       %d12 /    ;  include the carriage\n                //                       %d14-31 / ;  return, line feed, and\n                //                       %d127     ;  white space characters\n                //\n                // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n                charCode = token.codePointAt(0);\n\n                if (charCode !== 127 &&  internals.c1Controls(charCode)) {\n                    // Fatal error\n                    updateResult(internals.diagnoses.errExpectingQPair);\n                }\n                else if ((charCode < 31 && charCode !== 9) || charCode === 127) {\n                    // ' ' and '\\t' are allowed\n                    updateResult(internals.diagnoses.deprecatedQP);\n                }\n\n                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\n                context.prev = context.now;\n                // End of qpair\n                context.now = context.stack.pop();\n                const escapeToken = '\\\\' + token;\n\n                switch (context.now) {\n                    case internals.components.contextComment:\n                        break;\n\n                    case internals.components.contextQuotedString:\n                        parseData.local += escapeToken;\n                        atomData.locals[elementCount] += escapeToken;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                    case internals.components.literal:\n                        parseData.domain += escapeToken;\n                        atomData.domains[elementCount] += escapeToken;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                        // $lab:coverage:off$\n                    default:\n                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n                        // $lab:coverage:on$\n                }\n                break;\n\n                // Comment\n            case internals.components.contextComment:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n                //\n                //   ccontent = ctext / quoted-pair / comment\n                switch (token) {\n                    // Nested comment\n                    case '(':\n                        // Nested comments are ok\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // End of comment\n                    case ')':\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // CTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //   ctext         = %d33-39 /  ; Printable US-ASCII\n                        //                   %d42-91 /  ;  characters not including\n                        //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n                        //                   obs-ctext\n                        //\n                        //   obs-ctext     = obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n                        //                   %d11 /     ;  characters that do not\n                        //                   %d12 /     ;  include the carriage\n                        //                   %d14-31 /  ;  return, line feed, and\n                        //                   %d127      ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        if (charCode === 0 || charCode === 10 || (charCode !== 127 && internals.c1Controls(charCode))) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingCTEXT);\n                            break;\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedCTEXT);\n                        }\n                }\n\n                break;\n\n                // Folding white space\n            case internals.components.contextFWS:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n                //                                   ; Folding white space\n\n                // But note the erratum:\n                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n                //   In the obsolete syntax, any amount of folding white space MAY be\n                //   inserted where the obs-FWS rule is allowed.  This creates the\n                //   possibility of having two consecutive \"folds\" in a line, and\n                //   therefore the possibility that a line which makes up a folded header\n                //   field could be composed entirely of white space.\n                //\n                //   obs-FWS =   1*([CRLF] WSP)\n\n                if (prevToken === '\\r') {\n                    if (token === '\\r') {\n                        // Fatal error\n                        updateResult(internals.diagnoses.errFWSCRLFx2);\n                        break;\n                    }\n\n                    if (++crlfCount > 1) {\n                        // Multiple folds => obsolete FWS\n                        updateResult(internals.diagnoses.deprecatedFWS);\n                    }\n                    else {\n                        crlfCount = 1;\n                    }\n                }\n\n                switch (token) {\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                        }\n\n                        break;\n\n                    case ' ':\n                    case '\\t':\n                        break;\n\n                    default:\n                        if (prevToken === '\\r') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errFWSCRLFEnd);\n                        }\n\n                        crlfCount = 0;\n\n                        // End of FWS\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n\n                        // Look at this token again in the parent context\n                        --i;\n                }\n\n                prevToken = token;\n                break;\n\n                // Unexpected context\n                // $lab:coverage:off$\n            default:\n                throw new Error('unknown context: ' + context.now);\n                // $lab:coverage:on$\n        } // Primary state machine\n\n        if (maxResult > internals.categories.rfc5322) {\n            // Fatal error, no point continuing\n            break;\n        }\n    } // Token loop\n\n    // Check for errors\n    if (maxResult < internals.categories.rfc5322) {\n        const punycodeLength = Punycode.encode(parseData.domain).length;\n        // Fatal errors\n        if (context.now === internals.components.contextQuotedString) {\n            updateResult(internals.diagnoses.errUnclosedQuotedString);\n        }\n        else if (context.now === internals.components.contextQuotedPair) {\n            updateResult(internals.diagnoses.errBackslashEnd);\n        }\n        else if (context.now === internals.components.contextComment) {\n            updateResult(internals.diagnoses.errUnclosedComment);\n        }\n        else if (context.now === internals.components.literal) {\n            updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n        }\n        else if (token === '\\r') {\n            updateResult(internals.diagnoses.errFWSCRLFEnd);\n        }\n        else if (parseData.domain.length === 0) {\n            updateResult(internals.diagnoses.errNoDomain);\n        }\n        else if (elementLength === 0) {\n            updateResult(internals.diagnoses.errDotEnd);\n        }\n        else if (hyphenFlag) {\n            updateResult(internals.diagnoses.errDomainHyphenEnd);\n        }\n\n        // Other errors\n        else if (punycodeLength > 255) {\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n            //   The maximum total length of a domain name or number is 255 octets.\n            updateResult(internals.diagnoses.rfc5322DomainTooLong);\n        }\n        else if (Buffer.byteLength(parseData.local, 'utf8') + punycodeLength + /* '@' */ 1 > 254) {\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n            //   Forward-path   = Path\n            //\n            //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n            //\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n            //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n            //\n            // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n            // erratum to RFC 3696:\n            //\n            // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n            //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n            //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n            //   to be 254.\n            updateResult(internals.diagnoses.rfc5322TooLong);\n        }\n        else if (elementLength > 63) {\n            // http://tools.ietf.org/html/rfc1035#section-2.3.4\n            // labels   63 octets or less\n            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n        }\n        else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {\n            updateResult(internals.diagnoses.errDomainTooShort);\n        }\n        else if (options.tldWhitelist || options.tldBlacklist) {\n            const tldAtom = atomData.domains[elementCount];\n\n            if (!internals.validDomain(tldAtom, options)) {\n                updateResult(internals.diagnoses.errUnknownTLD);\n            }\n        }\n    } // Check for errors\n\n    // Finish\n    if (maxResult < internals.categories.dnsWarn) {\n        // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n        const code = atomData.domains[elementCount].codePointAt(0);\n\n        if (code <= 57) {\n            updateResult(internals.diagnoses.rfc5321TLDNumeric);\n        }\n    }\n\n    if (maxResult < threshold) {\n        maxResult = internals.diagnoses.valid;\n    }\n\n    const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\n\n    // $lab:coverage:off$\n    if (callback) {\n        callback(finishResult);\n    }\n    // $lab:coverage:on$\n\n    return finishResult;\n};\n\n\nexports.diagnoses = internals.validate.diagnoses = (function () {\n\n    const diag = {};\n    const keys = Object.keys(internals.diagnoses);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        diag[key] = internals.diagnoses[key];\n    }\n\n    return diag;\n})();\n\n\nexports.normalize = internals.normalize;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXNlbWFpbC9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNlbWFpbC9saWIvaW5kZXguanM/OTZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIExvYWQgbW9kdWxlc1xuXG5jb25zdCBQdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBoYXNPd246IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgaW5kZXhPZjogQXJyYXkucHJvdG90eXBlLmluZGV4T2YsXG4gICAgZGVmYXVsdFRocmVzaG9sZDogMTYsXG4gICAgbWF4SVB2Nkdyb3VwczogOCxcblxuICAgIGNhdGVnb3JpZXM6IHtcbiAgICAgICAgdmFsaWQ6idEsXG4gICAgICAgIGRuc1dhcm46idcsXG4gICAgICAgIHJmYzUzMjE6idE1LFxuICAgICAgICBjZndzOiAzMSxcbiAgICAgICAgZGVwcmVjYXRlZDogNjMsXG4gICAgICAgIHJmYzUzMjI6idEyNyxcbiAgICAgICAgZXJyb3I6idI1NVxuICAgIH0sXG5cbiAgICBkaWFnbm9zZXM6IHtcblxuICAgICAgICAvLyBBZGRyZXNzIGlzIHZhbGlkXG5cbiAgICAgICAgdmFsaWQ6idAsXG5cbiAgICAgICAgLy8gQWRkcmVzcyBpcyB2YWxpZCBmb3IgU01UUCBidXQgaGFzIHVudXN1YWwgZWxlbWVudHNcblxuICAgICAgICByZmM1MzIxVExEOiA5LFxuICAgICAgICByZmM1MzIxVExETnVtZXJpYzogMTAsXG4gICAgICAgIHJmYzUzMjFRdW90ZWRTdHJpbmc6idExLFxuICAgICAgICByZmM1MzIxQWRkcmVzc0xpdGVyYWw6idEyLFxuXG4gICAgICAgIC8vIEFkZHJlc3MgaXMgdmFsaWQgZm9yIG1lc3NhZ2UsIGJ1dCBtdXN0IGJlIG1vZGlmaWVkIGZvciBlbnZlbG9wZVxuXG4gICAgICAgIGNmd3NDb21tZW50OiAxNyxcbiAgICAgICAgY2Z3c0ZXUzogMTgsXG5cbiAgICAgICAgLy8gQWRkcmVzcyBjb250YWlucyBub24tQVNDSUkgd2hlbiB0aGUgYWxsb3dVbmljb2RlIG9wdGlvbiBpcyBmYWxzZVxuICAgICAgICAvLyBIYXMgdG8gYmUgPiBpbnRlcm5hbHMuZGVmYXVsdFRocmVzaG9sZCBzbyB0aGF0IGl0J3MgcmVqZWN0ZWRcbiAgICAgICAgLy8gd2l0aG91dCBhbiBleHBsaWNpdCBlcnJvckxldmVsOlxuICAgICAgICB1bmRlc2lyZWROb25Bc2NpaTogMjUsXG5cbiAgICAgICAgLy8gQWRkcmVzcyBjb250YWlucyBkZXByZWNhdGVkIGVsZW1lbnRzLCBidXQgbWF5IHN0aWxsIGJlIHZhbGlkIGluIHNvbWUgY29udGV4dHNcblxuICAgICAgICBkZXByZWNhdGVkTG9jYWxQYXJ0OiAzMyxcbiAgICAgICAgZGVwcmVjYXRlZEZXUzogMzQsXG4gICAgICAgIGRlcHJlY2F0ZWRRVEVYVDogMzUsXG4gICAgICAgIGRlcHJlY2F0ZWRRUDogMzYsXG4gICAgICAgIGRlcHJlY2F0ZWRDb21tZW50OiAzNyxcbiAgICAgICAgZGVwcmVjYXRlZENURVhUOiAzOCxcbiAgICAgICAgZGVwcmVjYXRlZElQdjY6idM5LFxuICAgICAgICBkZXByZWNhdGVkQ0ZXU05lYXJBdDogNDksXG5cbiAgICAgICAgLy8gQWRkcmVzcyBpcyBvbmx5IHZhbGlkIGFjY29yZGluZyB0byBicm9hZCBkZWZpbml0aW9uIGluIFJGQyA1MzIyLCBidXQgaXMgb3RoZXJ3aXNlIGludmFsaWRcblxuICAgICAgICByZmM1MzIyRG9tYWluOiA2NSxcbiAgICAgICAgcmZjNTMyMlRvb0xvbmc6idY2LFxuICAgICAgICByZmM1MzIyTG9jYWxUb29Mb25nOiA2NyxcbiAgICAgICAgcmZjNTMyMkRvbWFpblRvb0xvbmc6idY4LFxuICAgICAgICByZmM1MzIyTGFiZWxUb29Mb25nOiA2OSxcbiAgICAgICAgcmZjNTMyMkRvbWFpbkxpdGVyYWw6idcwLFxuICAgICAgICByZmM1MzIyRG9tYWluTGl0ZXJhbE9CU0RUZXh0OiA3MSxcbiAgICAgICAgcmZjNTMyMklQdjZHcm91cENvdW50OiA3MixcbiAgICAgICAgcmZjNTMyMklQdjYyeDJ4Q29sb246idczLFxuICAgICAgICByZmM1MzIySVB2NkJhZENoYXJhY3RlcjogNzQsXG4gICAgICAgIHJmYzUzMjJJUHY2TWF4R3JvdXBzOiA3NSxcbiAgICAgICAgcmZjNTMyMklQdjZDb2xvblN0YXJ0OiA3NixcbiAgICAgICAgcmZjNTMyMklQdjZDb2xvbkVuZDogNzcsXG5cbiAgICAgICAgLy8gQWRkcmVzcyBpcyBpbnZhbGlkIGZvciBhbnkgcHVycG9zZVxuXG4gICAgICAgIGVyckV4cGVjdGluZ0RURVhUOiAxMjksXG4gICAgICAgIGVyck5vTG9jYWxQYXJ0OiAxMzAsXG4gICAgICAgIGVyck5vRG9tYWluOiAxMzEsXG4gICAgICAgIGVyckNvbnNlY3V0aXZlRG90czogMTMyLFxuICAgICAgICBlcnJBVEVYVEFmdGVyQ0ZXUzogMTMzLFxuICAgICAgICBlcnJBVEVYVEFmdGVyUVM6idEzNCxcbiAgICAgICAgZXJyQVRFWFRBZnRlckRvbWFpbkxpdGVyYWw6idEzNSxcbiAgICAgICAgZXJyRXhwZWN0aW5nUVBhaXI6idEzNixcbiAgICAgICAgZXJyRXhwZWN0aW5nQVRFWFQ6idEzNyxcbiAgICAgICAgZXJyRXhwZWN0aW5nUVRFWFQ6idEzOCxcbiAgICAgICAgZXJyRXhwZWN0aW5nQ1RFWFQ6idEzOSxcbiAgICAgICAgZXJyQmFja3NsYXNoRW5kOiAxNDAsXG4gICAgICAgIGVyckRvdFN0YXJ0OiAxNDEsXG4gICAgICAgIGVyckRvdEVuZDogMTQyLFxuICAgICAgICBlcnJEb21haW5IeXBoZW5TdGFydDogMTQzLFxuICAgICAgICBlcnJEb21haW5IeXBoZW5FbmQ6idE0NCxcbiAgICAgICAgZXJyVW5jbG9zZWRRdW90ZWRTdHJpbmc6idE0NSxcbiAgICAgICAgZXJyVW5jbG9zZWRDb21tZW50OiAxNDYsXG4gICAgICAgIGVyclVuY2xvc2VkRG9tYWluTGl0ZXJhbDogMTQ3LFxuICAgICAgICBlcnJGV1NDUkxGeDI6idE0OCxcbiAgICAgICAgZXJyRldTQ1JMRkVuZDogMTQ5LFxuICAgICAgICBlcnJDUk5vTEY6idE1MCxcbiAgICAgICAgZXJyVW5rbm93blRMRDogMTYwLFxuICAgICAgICBlcnJEb21haW5Ub29TaG9ydDogMTYxXG4gICAgfSxcblxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgbG9jYWxwYXJ0OiAwLFxuICAgICAgICBkb21haW46idEsXG4gICAgICAgIGxpdGVyYWw6idIsXG4gICAgICAgIGNvbnRleHRDb21tZW50OiAzLFxuICAgICAgICBjb250ZXh0RldTOiA0LFxuICAgICAgICBjb250ZXh0UXVvdGVkU3RyaW5nOiA1LFxuICAgICAgICBjb250ZXh0UXVvdGVkUGFpcjogNlxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNwZWNpYWxzid0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgc3BlY2lhbHMgPSAnKCk8PltdOjtAXFxcXCwuXCInOyAgICAgICAgLy8gVVMtQVNDSUkgdmlzaWJsZSBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBmb3IgYXRleHQgKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjIuMylcbiAgICBjb25zdCBsb29rdXAgPSBuZXcgQXJyYXkoMHgxMDApO1xuICAgIGxvb2t1cC5maWxsKGZhbHNlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpidwgc3BlY2lhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbG9va3VwW3NwZWNpYWxzLmNvZGVQb2ludEF0KGkpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGxvb2t1cFtjb2RlXTtcbiAgICB9O1xufSgpO1xuXG5pbnRlcm5hbHMuYzBDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGxvb2t1cCA9IG5ldyBBcnJheSgweDEwMCk7XG4gICAgbG9va3VwLmZpbGwoZmFsc2UpO1xuXG4gICAgLy8gYWRkIEMwIGNvbnRyb2wgY2hhcmFjdGVyc1xuXG4gICAgZm9yIChsZXQgaSA9idA7IGkgPCAzMzsgKytpKSB7XG4gICAgICAgIGxvb2t1cFtpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGxvb2t1cFtjb2RlXTtcbiAgICB9O1xufSgpO1xuXG5pbnRlcm5hbHMuYzFDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGxvb2t1cCA9IG5ldyBBcnJheSgweDEwMCk7XG4gICAgbG9va3VwLmZpbGwoZmFsc2UpO1xuXG4gICAgLy8gYWRkIEMxIGNvbnRyb2wgY2hhcmFjdGVyc1xuXG4gICAgZm9yIChsZXQgaSA9idEyNzsgaSA8idE2MDsgKytpKSB7XG4gICAgICAgIGxvb2t1cFtpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGxvb2t1cFtjb2RlXTtcbiAgICB9O1xufSgpO1xuXG5pbnRlcm5hbHMucmVnZXggPSB7XG4gICAgaXBWNDogL1xcYig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICAgIGlwVjY6IC9eW2EtZkEtRlxcZF17MCw0fSQvXG59O1xuXG5pbnRlcm5hbHMubm9ybWFsaXplU3VwcG9ydHNOdWwgPSAnXFwwJy5ub3JtYWxpemUoJ05GQycpid09PSAnXFwwJztcblxuXG4vLyAkbGFiOmNvdmVyYWdlOm9mZiRcbmludGVybmFscy5udWxOb3JtYWxpemUgPSBmdW5jdGlvbiAoZW1haWwpIHtcblxuICAgIHJldHVybiBlbWFpbC5zcGxpdCgnXFwwJykubWFwKChwYXJ0KSA9PiBwYXJ0Lm5vcm1hbGl6ZSgnTkZDJykpLmpvaW4oJ1xcMCcpO1xufTtcbi8vICRsYWI6Y292ZXJhZ2U6b24kXG5cblxuaW50ZXJuYWxzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChlbWFpbCkge1xuXG4gICAgLy8gJGxhYjpjb3ZlcmFnZTpvZmYkXG4gICAgaWYgKCFpbnRlcm5hbHMubm9ybWFsaXplU3VwcG9ydHNOdWwgJiYgZW1haWwuaW5kZXhPZignXFwwJykgPj0gMCkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm51bE5vcm1hbGl6ZShlbWFpbCk7XG4gICAgfVxuICAgIC8vICRsYWI6Y292ZXJhZ2U6b24kXG5cbiAgICByZXR1cm4gZW1haWwubm9ybWFsaXplKCdORkMnKTtcbn07XG5cblxuaW50ZXJuYWxzLmNoZWNrSXBWNiA9IGZ1bmN0aW9uIChpdGVtcykge1xuXG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KCh2YWx1ZSkgPT4gaW50ZXJuYWxzLnJlZ2V4LmlwVjYudGVzdCh2YWx1ZSkpO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWREb21haW4gPSBmdW5jdGlvbiAodGxkQXRvbSwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMudGxkQmxhY2tsaXN0KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudGxkQmxhY2tsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5pbmRleE9mLmNhbGwob3B0aW9ucy50bGRCbGFja2xpc3QsIHRsZEF0b20pid09PSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhaW50ZXJuYWxzLmhhc093bi5jYWxsKG9wdGlvbnMudGxkQmxhY2tsaXN0LCB0bGRBdG9tKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRsZFdoaXRlbGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5pbmRleE9mLmNhbGwob3B0aW9ucy50bGRXaGl0ZWxpc3QsIHRsZEF0b20pICE9PSAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmhhc093bi5jYWxsKG9wdGlvbnMudGxkV2hpdGVsaXN0LCB0bGRBdG9tKTtcbn07XG5cblxuLyoqXG4gKiBDaGVjayB0aGF0IGFuIGVtYWlsIGFkZHJlc3MgY29uZm9ybXMgdG8gUkZDcyA1MzIxLCA1MzIyLCA2NTMwIGFuZCBvdGhlcnNcbiAqXG4gKiBXZSBkaXN0aW5ndWlzaCBjbGVhcmx5IGJldHdlZW4gYSBNYWlsYm94IGFzIGRlZmluZWQgYnkgUkZDidUzMjEgYW5kIGFuXG4gKiBhZGRyLXNwZWMgYXMgZGVmaW5lZCBieSBSRkMgNTMyMi4gRGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0LCBlaXRoZXIgY2FuIGJlXG4gKiByZWdhcmRlZCBhcyBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuIFRoZSBSRkMgNTMyMSBNYWlsYm94IHNwZWNpZmljYXRpb24gaXNcbiAqIG1vcmUgcmVzdHJpY3RpdmUgKGNvbW1lbnRzLCB3aGl0ZSBzcGFjZSBhbmQgb2Jzb2xldGUgZm9ybXMgYXJlIG5vdCBhbGxvd2VkKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3MgdG8gY2hlY2suIFNlZSBSRUFETUUgZm9yIHNwZWNpZmljcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSAob3B0aW9uYWwpIG9wdGlvbnM6XG4gKiAgIHsqfSBlcnJvckxldmVsIERldGVybWluZXMgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdmFsaWQgYW5kIGludmFsaWRcbiAqICAgICBhZGRyZXNzZXMuXG4gKiAgIHsqfSB0bGRCbGFja2xpc3QgVGhlIHNldCBvZiBkb21haW5zIHRvIGNvbnNpZGVyIGludmFsaWQuXG4gKiAgIHsqfSB0bGRXaGl0ZWxpc3QgVGhlIHNldCBvZiBkb21haW5zIHRvIGNvbnNpZGVyIHZhbGlkLlxuICogICB7Kn0gYWxsb3dVbmljb2RlIFdoZXRoZXIgdG8gYWxsb3cgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGRlZmF1bHRzIHRvIHRydWUuXG4gKiAgIHsqfSBtaW5Eb21haW5BdG9tcyBUaGUgbWluaW11bSBudW1iZXIgb2YgZG9tYWluIGF0b21zIHdoaWNoIG11c3QgYmUgcHJlc2VudFxuICogICAgIGZvciB0aGUgYWRkcmVzcyB0byBiZSB2YWxpZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyfGJvb2xlYW4pfSBjYWxsYmFjayBUaGUgKG9wdGlvbmFsKSBjYWxsYmFjayBoYW5kbGVyLlxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5leHBvcnRzLnZhbGlkYXRlid0gaW50ZXJuYWxzLnZhbGlkYXRlid0gZnVuY3Rpb24gKGVtYWlsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZW1haWwgPSBpbnRlcm5hbHMubm9ybWFsaXplKGVtYWlsKTtcblxuICAgIC8vIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLlxuICAgIC8vICRsYWI6Y292ZXJhZ2U6b2ZmJFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrid0gbnVsbDtcbiAgICB9XG4gICAgLy8gJGxhYjpjb3ZlcmFnZTpvbiRcblxuICAgIGxldCBkaWFnbm9zZTtcbiAgICBsZXQgdGhyZXNob2xkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmVycm9yTGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRpYWdub3Nlid0gdHJ1ZTtcbiAgICAgICAgdGhyZXNob2xkid0gb3B0aW9ucy5lcnJvckxldmVsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGlhZ25vc2UgPSAhIW9wdGlvbnMuZXJyb3JMZXZlbDtcbiAgICAgICAgdGhyZXNob2xkid0gaW50ZXJuYWxzLmRpYWdub3Nlcy52YWxpZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRXaGl0ZWxpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRsZFdoaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGxkV2hpdGVsaXN0id0gW29wdGlvbnMudGxkV2hpdGVsaXN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy50bGRXaGl0ZWxpc3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhcnJheSBvciBvYmplY3QgdGxkV2hpdGVsaXN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRCbGFja2xpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRsZEJsYWNrbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGxkQmxhY2tsaXN0id0gW29wdGlvbnMudGxkQmxhY2tsaXN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy50bGRCbGFja2xpc3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhcnJheSBvciBvYmplY3QgdGxkQmxhY2tsaXN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5taW5Eb21haW5BdG9tcyAmJiAob3B0aW9ucy5taW5Eb21haW5BdG9tcyAhPT0gKCgrb3B0aW9ucy5taW5Eb21haW5BdG9tcykgfCAwKSB8fCBvcHRpb25zLm1pbkRvbWFpbkF0b21zidwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlciBtaW5Eb21haW5BdG9tcycpO1xuICAgIH1cblxuICAgIGxldCBtYXhSZXN1bHQgPSBpbnRlcm5hbHMuZGlhZ25vc2VzLnZhbGlkO1xuICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9ICh2YWx1ZSkgPT4ge1xuXG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFJlc3VsdCkge1xuICAgICAgICAgICAgbWF4UmVzdWx0id0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWxsb3dVbmljb2Rlid0gb3B0aW9ucy5hbGxvd1VuaWNvZGUgPT09IHVuZGVmaW5lZCB8fCAhIW9wdGlvbnMuYWxsb3dVbmljb2RlO1xuICAgIGlmICghYWxsb3dVbmljb2RlICYmIC9bXlxceDAwLVxceDdmXS8udGVzdChlbWFpbCkpIHtcbiAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMudW5kZXNpcmVkTm9uQXNjaWkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5vdzogaW50ZXJuYWxzLmNvbXBvbmVudHMubG9jYWxwYXJ0LFxuICAgICAgICBwcmV2OiBpbnRlcm5hbHMuY29tcG9uZW50cy5sb2NhbHBhcnQsXG4gICAgICAgIHN0YWNrOiBbaW50ZXJuYWxzLmNvbXBvbmVudHMubG9jYWxwYXJ0XVxuICAgIH07XG5cbiAgICBsZXQgcHJldlRva2Vuid0gJyc7XG5cbiAgICBjb25zdCBwYXJzZURhdGEgPSB7XG4gICAgICAgIGxvY2FsOiAnJyxcbiAgICAgICAgZG9tYWluOiAnJ1xuICAgIH07XG4gICAgY29uc3QgYXRvbURhdGEgPSB7XG4gICAgICAgIGxvY2FsczogWycnXSxcbiAgICAgICAgZG9tYWluczogWycnXVxuICAgIH07XG5cbiAgICBsZXQgZWxlbWVudENvdW50id0gMDtcbiAgICBsZXQgZWxlbWVudExlbmd0aCA9idA7XG4gICAgbGV0IGNybGZDb3VudCA9idA7XG4gICAgbGV0IGNoYXJDb2RlO1xuXG4gICAgbGV0IGh5cGhlbkZsYWcgPSBmYWxzZTtcbiAgICBsZXQgYXNzZXJ0RW5kid0gZmFsc2U7XG5cbiAgICBjb25zdCBlbWFpbExlbmd0aCA9IGVtYWlsLmxlbmd0aDtcblxuICAgIGxldCB0b2tlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRva2VuIGlzIHVzZWQgb3V0c2lkZSB0aGUgbG9vcCwgbXVzdCBkZWNsYXJlIHNpbWlsYXJseVxuICAgIGZvciAobGV0IGkgPSAwOyBpidwgZW1haWxMZW5ndGg7IGkgKz0gdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFV0aWxpemUgY29kZXBvaW50cyB0byBhY2NvdW50IGZvciBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyc1xuICAgICAgICB0b2tlbiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGVtYWlsLmNvZGVQb2ludEF0KGkpKTtcblxuICAgICAgICBzd2l0Y2ggKGNvbnRleHQubm93KSB7XG4gICAgICAgICAgICAvLyBMb2NhbC1wYXJ0XG4gICAgICAgICAgICBjYXNlIGludGVybmFscy5jb21wb25lbnRzLmxvY2FscGFydDpcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy40LjFcbiAgICAgICAgICAgICAgICAvLyAgIGxvY2FsLXBhcnQgICAgICA9ICAgZG90LWF0b20gLyBxdW90ZWQtc3RyaW5nIC8gb2JzLWxvY2FsLXBhcnRcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgZG90LWF0b20gICAgICAgid0gICBbQ0ZXU10gZG90LWF0b20tdGV4dCBbQ0ZXU11cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgZG90LWF0b20tdGV4dCAgid0gICAxKmF0ZXh0ICooXCIuXCIgMSphdGV4dClcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgcXVvdGVkLXN0cmluZyAgid0gICBbQ0ZXU11cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgRFFVT1RFICooW0ZXU10gcWNvbnRlbnQpIFtGV1NdIERRVU9URVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICBbQ0ZXU11cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgb2JzLWxvY2FsLXBhcnQgid0gICB3b3JkICooXCIuXCIgd29yZClcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgd29yZCAgICAgICAgICAgid0gICBhdG9tIC8gcXVvdGVkLXN0cmluZ1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBhdG9tICAgICAgICAgICAgPSAgIFtDRldTXSAxKmF0ZXh0IFtDRldTXVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudFxuICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TGVuZ3Roid09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudHMgYXJlIE9LIGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChlbGVtZW50Q291bnQgPT09idAgPyBpbnRlcm5hbHMuZGlhZ25vc2VzLmNmd3NDb21tZW50idogaW50ZXJuYWxzLmRpYWdub3Nlcy5kZXByZWNhdGVkQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5jZndzQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHN0YXJ0IGEgY29tbWVudCBpbiBhbiBlbGVtZW50LCBzaG91bGQgYmUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RW5kid0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjay5wdXNoKGNvbnRleHQubm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm93id0gaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dENvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCBkb3QtYXRvbSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRMZW5ndGggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbm90aGVyIGRvdCwgYWxyZWFkeT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoZWxlbWVudENvdW50id09PSAwid8gaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJEb3RTdGFydCA6IGludGVybmFscy5kaWFnbm9zZXMuZXJyQ29uc2VjdXRpdmVEb3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbnRpcmUgbG9jYWwtcGFydCBjYW4gYmUgYSBxdW90ZWQgc3RyaW5nIGZvciBSRkMgNTMyMTsgaWYgb25lIGF0b20gaXMgcXVvdGVkIGl0J3MgYW4gUkZDidUzMjIgb2Jzb2xldGUgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3NlcnRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZGVwcmVjYXRlZExvY2FsUGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ0ZXUyAmIHF1b3RlZCBzdHJpbmdzIGFyZSBPSyBhZ2FpbiBub3cgd2UncmUgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBlbGVtZW50IChhbHRob3VnaCB0aGV5IGFyZSBvYnNvbGV0ZSBmb3JtcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TGVuZ3Roid0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2VsZW1lbnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEubG9jYWwgKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRvbURhdGEubG9jYWxzW2VsZW1lbnRDb3VudF0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1b3RlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRMZW5ndGggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW50aXJlIGxvY2FsLXBhcnQgY2FuIGJlIGEgcXVvdGVkIHN0cmluZyBmb3IgUkZDidUzMjE7IGlmIG9uZSBhdG9tIGlzIHF1b3RlZCBpdCdzIGFuIFJGQyA1MzIyIG9ic29sZXRlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoZWxlbWVudENvdW50id09PSAwid8gaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIxUXVvdGVkU3RyaW5nidogaW50ZXJuYWxzLmRpYWdub3Nlcy5kZXByZWNhdGVkTG9jYWxQYXJ0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YS5sb2NhbCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdG9tRGF0YS5sb2NhbHNbZWxlbWVudENvdW50XSArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHRva2VuLCAndXRmOCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVvdGVkIHN0cmluZyBtdXN0IGJlIHRoZSBlbnRpcmUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjay5wdXNoKGNvbnRleHQubm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRRdW90ZWRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJFeHBlY3RpbmdBVEVYVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xkaW5nIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1haWxMZW5ndGggPT09ICsraSB8fCBlbWFpbFtpXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckNSTm9MRik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChlbGVtZW50Q291bnQgPT09idAgPyBpbnRlcm5hbHMuZGlhZ25vc2VzLmNmd3NGV1MgOiBpbnRlcm5hbHMuZGlhZ25vc2VzLmRlcHJlY2F0ZWRGV1MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgRldTIGluIHRoZSBtaWRkbGUgb2YgYW4gZWxlbWVudCwgYmV0dGVyIGJlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sucHVzaChjb250ZXh0Lm5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRGV1M7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBzaG91bGQgaGF2ZSBhIHZhbGlkIGxvY2FsLXBhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6b2ZmJFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3RhY2subGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGl0ZW0gb24gY29udGV4dCBzdGFjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTpvbiRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlRGF0YS5sb2NhbC5sZW5ndGggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyck5vTG9jYWxQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnRMZW5ndGggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckRvdEVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4xIHRoZSBtYXhpbXVtIHRvdGFsIGxlbmd0aCBvZiBhIHVzZXIgbmFtZSBvciBvdGhlciBsb2NhbC1wYXJ0IGlzidY0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBvY3RldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBhcnNlRGF0YS5sb2NhbCwgJ3V0ZjgnKSA+idY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMkxvY2FsVG9vTG9uZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy40LjEgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGUgc3BhY2UgU0hPVUxEIE5PVCBiZSB1c2VkIGFyb3VuZCBcIkBcIiBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGFkZHItc3BlY1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIxMTlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vidQuIFNIT1VMRCBOT1QgdGhpcyBwaHJhc2UsIG9yIHRoZSBwaHJhc2UgXCJOT1QgUkVDT01NRU5ERURcIiBtZWFuIHRoYXQgdGhlcmUgbWF5IGV4aXN0IHZhbGlkIHJlYXNvbnMgaW4gcGFydGljdWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgY2lyY3Vtc3RhbmNlcyB3aGVuIHRoZSBwYXJ0aWN1bGFyIGJlaGF2aW9yIGlzIGFjY2VwdGFibGUgb3IgZXZlbiB1c2VmdWwsIGJ1dCB0aGUgZnVsbCBpbXBsaWNhdGlvbnMgc2hvdWxkIGJlIHVuZGVyc3Rvb2RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGFuZCB0aGUgY2FzZSBjYXJlZnVsbHkgd2VpZ2hlZCBiZWZvcmUgaW1wbGVtZW50aW5nIGFueSBiZWhhdmlvciBkZXNjcmliZWQgd2l0aCB0aGlzIGxhYmVsLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5wcmV2id09PSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0Q29tbWVudCB8fCBjb250ZXh0LnByZXYgPT09IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRGV1MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5kZXByZWNhdGVkQ0ZXU05lYXJBdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGV2ZXJ5dGhpbmcgZG93biBmb3IgdGhlIGRvbWFpbiBwYXJzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGludGVybmFscy5jb21wb25lbnRzLmRvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2tbMF0gPSBpbnRlcm5hbHMuY29tcG9uZW50cy5kb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCA9idA7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRFbmQgPSBmYWxzZTsgLy8gQ0ZXUyBjYW4gb25seSBhcHBlYXIgYXQgdGhlIGVuZCBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFURVhUXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy4yLjNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGF0ZXh0id0gQUxQSEEgLyBESUdJVCAvidsgUHJpbnRhYmxlIFVTLUFTQ0lJXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiIVwiIC8gXCIjXCIgLyAgICAgOyAgY2hhcmFjdGVycyBub3QgaW5jbHVkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiJFwiIC8gXCIlXCIgLyAgICAgOyAgc3BlY2lhbHMuICBVc2VkIGZvciBhdG9tcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCImXCIgLyBcIidcIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiKlwiIC8gXCIrXCIgL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBcIi1cIiAvIFwiL1wiIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCI9XCIgLyBcIj9cIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiXlwiIC8gXCJfXCIgL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBcImBcIiAvIFwie1wiIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCJ8XCIgLyBcIn1cIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiflwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBlbmNvdW50ZXJlZCBhdGV4dCB3aGVyZSBpdCBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbnRleHQucHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRDb21tZW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRGV1M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJBVEVYVEFmdGVyQ0ZXUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRRdW90ZWRTdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJBVEVYVEFmdGVyUVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6b2ZmJFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb3JlIGF0ZXh0IGZvdW5kIHdoZXJlIG5vbmUgaXMgYWxsb3dlZCwgYnV0IHVucmVjb2duaXplZCBwcmV2IGNvbnRleHQ6ICcgKyBjb250ZXh0LnByZXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTpvbiRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByZXYgPSBjb250ZXh0Lm5vdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHRva2VuLmNvZGVQb2ludEF0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBpZiBjaGFyQ29kZSA9PSAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuc3BlY2lhbHMoY2hhckNvZGUpIHx8IGludGVybmFscy5jMENvbnRyb2xzKGNoYXJDb2RlKSB8fCBpbnRlcm5hbHMuYzFDb250cm9scyhjaGFyQ29kZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJFeHBlY3RpbmdBVEVYVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhLmxvY2FsICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhLmxvY2Fsc1tlbGVtZW50Q291bnRdICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRMZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodG9rZW4sICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMuZG9tYWluOlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjQuMVxuICAgICAgICAgICAgICAgIC8vICAgZG9tYWluICAgICAgICAgid0gICBkb3QtYXRvbSAvIGRvbWFpbi1saXRlcmFsIC8gb2JzLWRvbWFpblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBkb3QtYXRvbSAgICAgICAgPSAgIFtDRldTXSBkb3QtYXRvbS10ZXh0IFtDRldTXVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBkb3QtYXRvbS10ZXh0ICAgPSAgidEqYXRleHQgKihcIi5cIiAxKmF0ZXh0KVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBkb21haW4tbGl0ZXJhbCAgPSAgIFtDRldTXSBcIltcIiAqKFtGV1NdIGR0ZXh0KSBbRldTXSBcIl1cIiBbQ0ZXU11cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgZHRleHQgICAgICAgICAgid0gICAlZDMzLTkwIC8gICAgICAgICAgOyBQcmludGFibGUgVVMtQVNDSUlcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgJWQ5NC0xMjYgLyAgICAgICAgidsgIGNoYXJhY3RlcnMgbm90IGluY2x1ZGluZ1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICBvYnMtZHRleHQgICAgICAgICAgOyAgXCJbXCIsIFwiXVwiLCBvciBcIlxcXCJcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgb2JzLWRvbWFpbiAgICAgid0gICBhdG9tICooXCIuXCIgYXRvbSlcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgYXRvbSAgICAgICAgICAgid0gICBbQ0ZXU10gMSphdGV4dCBbQ0ZXU11cblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjEjc2VjdGlvbi00LjEuMlxuICAgICAgICAgICAgICAgIC8vICAgTWFpbGJveCAgICAgICAgPSBMb2NhbC1wYXJ0IFwiQFwiICggRG9tYWluIC8gYWRkcmVzcy1saXRlcmFsIClcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgRG9tYWluICAgICAgICAgPSBzdWItZG9tYWluICooXCIuXCIgc3ViLWRvbWFpbilcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgYWRkcmVzcy1saXRlcmFsICA9IFwiW1wiICggSVB2NC1hZGRyZXNzLWxpdGVyYWwgL1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBJUHY2LWFkZHJlc3MtbGl0ZXJhbCAvXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEdlbmVyYWwtYWRkcmVzcy1saXRlcmFsICkgXCJdXCJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgOyBTZWUgU2VjdGlvbiA0LjEuM1xuXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMiNzZWN0aW9uLTMuNC4xXG4gICAgICAgICAgICAgICAgLy8gICAgICBOb3RlOiBBIGxpYmVyYWwgc3ludGF4IGZvciB0aGUgZG9tYWluIHBvcnRpb24gb2YgYWRkci1zcGVjIGlzXG4gICAgICAgICAgICAgICAgLy8gICAgICBnaXZlbiBoZXJlLiAgSG93ZXZlciwgdGhlIGRvbWFpbiBwb3J0aW9uIGNvbnRhaW5zIGFkZHJlc3NpbmdcbiAgICAgICAgICAgICAgICAvLyAgICAgIGluZm9ybWF0aW9uIHNwZWNpZmllZCBieSBhbmQgdXNlZCBpbiBvdGhlciBwcm90b2NvbHMgKGUuZy4sXG4gICAgICAgICAgICAgICAgLy8gICAgICBbUkZDMTAzNF0sIFtSRkMxMDM1XSwgW1JGQzExMjNdLCBbUkZDNTMyMV0pLiAgSXQgaXMgdGhlcmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gICAgICBpbmN1bWJlbnQgdXBvbiBpbXBsZW1lbnRhdGlvbnMgdG8gY29uZm9ybSB0byB0aGUgc3ludGF4IG9mXG4gICAgICAgICAgICAgICAgLy8gICAgICBhZGRyZXNzZXMgZm9yIHRoZSBjb250ZXh0IGluIHdoaWNoIHRoZXkgYXJlIHVzZWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpc19lbWFpbCgpIGF1dGhvcidzIG5vdGU6IGl0J3Mgbm90IGNsZWFyIGhvdyB0byBpbnRlcnByZXQgdGhpcyBpblxuICAgICAgICAgICAgICAgIC8vIGhlIGNvbnRleHQgb2YgYSBnZW5lcmFsIGVtYWlsIGFkZHJlc3MgdmFsaWRhdG9yLiBUaGUgY29uY2x1c2lvbiBJXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSByZWFjaGVkIGlzIHRoaXM6IFwiYWRkcmVzc2luZyBpbmZvcm1hdGlvblwiIG11c3QgY29tcGx5IHdpdGhcbiAgICAgICAgICAgICAgICAvLyBSRkMgNTMyMSAoYW5kIGluIHR1cm4gUkZDidEwMzUpLCBhbnl0aGluZyB0aGF0IGlzIFwic2VtYW50aWNhbGx5XG4gICAgICAgICAgICAgICAgLy8gaW52aXNpYmxlXCIgbXVzdCBjb21wbHkgb25seSB3aXRoIFJGQyA1MzIyLlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudFxuICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TGVuZ3Roid09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWVudHMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkb21haW4gYXJlIGRlcHJlY2F0ZWQgaW4gdGhlIHRleHQsIGNvbW1lbnRzIGF0IHRoZSBzdGFydCBvZiBhIHN1YmRvbWFpbiBhcmUgb2JzLWRvbWFpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjQuMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChlbGVtZW50Q291bnQgPT09idAgPyBpbnRlcm5hbHMuZGlhZ25vc2VzLmRlcHJlY2F0ZWRDRldTTmVhckF0idogaW50ZXJuYWxzLmRpYWdub3Nlcy5kZXByZWNhdGVkQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBhIGNvbW1lbnQgbWlkLWVsZW1lbnQsIGJldHRlciBiZSBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RW5kid0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5jZndzQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sucHVzaChjb250ZXh0Lm5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRDb21tZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHQgZG90LWF0b20gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1bnljb2RlTGVuZ3Roid0gUHVueWNvZGUuZW5jb2RlKGF0b21EYXRhLmRvbWFpbnNbZWxlbWVudENvdW50XSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRMZW5ndGggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbm90aGVyIGRvdCwgYWxyZWFkeT8gRmF0YWwgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGVsZW1lbnRDb3VudCA9PT0gMCA/IGludGVybmFscy5kaWFnbm9zZXMuZXJyRG90U3RhcnQgOiBpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckNvbnNlY3V0aXZlRG90cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoeXBoZW5GbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmlvdXMgc3ViZG9tYWluIGVuZGVkIGluIGEgaHlwaGVuLiBGYXRhbCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJEb21haW5IeXBoZW5FbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHVueWNvZGVMZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJGQyA1ODkwIHNwZWNpZmllcyB0aGF0IGRvbWFpbiBsYWJlbHMgdGhhdCBhcmUgZW5jb2RlZCB1c2luZyB0aGUgUHVueWNvZGUgYWxnb3JpdGhtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbXVzdCBhZGhlcmUgdG8gdGhlidw9idYzIG9jdGV0IHJlcXVpcmVtZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgc3RyaW5nIHByZWZpeGVzIGZyb20gdGhlIFB1bnljb2RlIGFsZ29yaXRobS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1ODkwI3NlY3Rpb24tMi4zLjIuMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhYmVscyAgICAgICAgICA2MyBvY3RldHMgb3IgbGVzc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMkxhYmVsVG9vTG9uZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENGV1MgaXMgT0sgYWdhaW4gbm93IHdlJ3JlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gZWxlbWVudCAoYWx0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IG1heSBiZSBvYnNvbGV0ZSBDRldTKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RW5kid0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TGVuZ3Roid0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrZWxlbWVudENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbURhdGEuZG9tYWluc1tlbGVtZW50Q291bnRdid0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEuZG9tYWluICs9IHRva2VuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9tYWluIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VEYXRhLmRvbWFpbi5sZW5ndGggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb21haW4gbGl0ZXJhbCBtdXN0IGJlIHRoZSBvbmx5IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0b2tlbiwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLnB1c2goY29udGV4dC5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm93id0gaW50ZXJuYWxzLmNvbXBvbmVudHMubGl0ZXJhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEuZG9tYWluICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhLmRvbWFpbnNbZWxlbWVudENvdW50XSArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEubGl0ZXJhbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmF0YWwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJFeHBlY3RpbmdBVEVYVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xkaW5nIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1haWxMZW5ndGggPT09ICsraSB8fCBlbWFpbFtpXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckNSTm9MRik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChlbGVtZW50Q291bnQgPT09idAgPyBpbnRlcm5hbHMuZGlhZ25vc2VzLmRlcHJlY2F0ZWRDRldTTmVhckF0idogaW50ZXJuYWxzLmRpYWdub3Nlcy5kZXByZWNhdGVkRldTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IEZXUyBpbiB0aGUgbWlkZGxlIG9mIGFuIGVsZW1lbnQsIHNvIHRoaXMgYmV0dGVyIGJlIHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5jZndzRldTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLnB1c2goY29udGV4dC5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub3cgPSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0RldTO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlRva2Vuid0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGJlIEFURVhUXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSRkMgNTMyMiBhbGxvd3MgYW55IGF0ZXh0Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy4yLjNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGF0ZXh0id0gQUxQSEEgLyBESUdJVCAvidsgUHJpbnRhYmxlIFVTLUFTQ0lJXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiIVwiIC8gXCIjXCIgLyAgICAgOyAgY2hhcmFjdGVycyBub3QgaW5jbHVkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiJFwiIC8gXCIlXCIgLyAgICAgOyAgc3BlY2lhbHMuICBVc2VkIGZvciBhdG9tcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCImXCIgLyBcIidcIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiKlwiIC8gXCIrXCIgL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBcIi1cIiAvIFwiL1wiIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCI9XCIgLyBcIj9cIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiXlwiIC8gXCJfXCIgL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBcImBcIiAvIFwie1wiIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXCJ8XCIgLyBcIn1cIiAvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiflwiXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBSRkMgNTMyMSBvbmx5IGFsbG93cyBsZXR0ZXItZGlnaXQtaHlwaGVuIHRvIGNvbXBseSB3aXRoIEROUyBydWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAoUkZDcyAxMDM0ICYgMTEyMylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjEjc2VjdGlvbi00LjEuMlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBzdWItZG9tYWluICAgICA9IExldC1kaWcgW0xkaC1zdHJdXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBMZXQtZGlnICAgICAgICA9IEFMUEhBIC8gRElHSVRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIExkaC1zdHIgICAgICAgid0gKiggQUxQSEEgLyBESUdJVCAvIFwiLVwiICkgTGV0LWRpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3NlcnRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGVuY291bnRlcmVkIEFURVhUIHdoZXJlIGl0IGlzIG5vIGxvbmdlciB2YWxpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29udGV4dC5wcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dENvbW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dEZXUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckFURVhUQWZ0ZXJDRldTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMubGl0ZXJhbDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckFURVhUQWZ0ZXJEb21haW5MaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOm9mZiRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW9yZSBhdGV4dCBmb3VuZCB3aGVyZSBub25lIGlzIGFsbG93ZWQsIGJ1dCB1bnJlY29nbml6ZWQgcHJldiBjb250ZXh0OiAnICsgY29udGV4dC5wcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6b24kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHRva2VuLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHRoaXMgdG9rZW4gaXNuJ3QgYSBoeXBoZW4gdW5sZXNzIHdlIGRpc2NvdmVyIGl0IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICBoeXBoZW5GbGFnid0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuc3BlY2lhbHMoY2hhckNvZGUpIHx8IGludGVybmFscy5jMENvbnRyb2xzKGNoYXJDb2RlKSB8fCBpbnRlcm5hbHMuYzFDb250cm9scyhjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckV4cGVjdGluZ0FURVhUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2Vuid09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIeXBoZW5zIGNhbm5vdCBiZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc3ViZG9tYWluLCBmYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJEb21haW5IeXBoZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlwaGVuRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgbmVpdGhlciBhIG51bWJlciBub3IgYSBsYXRpbi91bmljb2RlIGxldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhckNvZGUgPCA0OCB8fCAoY2hhckNvZGUgPiAxMjIgJiYgY2hhckNvZGUgPCAxOTIpIHx8IChjaGFyQ29kZSA+idU3ICYmIGNoYXJDb2RlidwgNjUpIHx8IChjaGFyQ29kZSA+idkwICYmIGNoYXJDb2RlidwgOTcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgYW4gUkZDidUzMjEgc3ViZG9tYWluLCBidXQgc3RpbGwgT0sgYnkgUkZDidUzMjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIyRG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhLmRvbWFpbiArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhLmRvbWFpbnNbZWxlbWVudENvdW50XSArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRMZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodG9rZW4sICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvLyBEb21haW4gbGl0ZXJhbFxuICAgICAgICAgICAgY2FzZSBpbnRlcm5hbHMuY29tcG9uZW50cy5saXRlcmFsOlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjQuMVxuICAgICAgICAgICAgICAgIC8vICAgZG9tYWluLWxpdGVyYWwgid0gICBbQ0ZXU10gXCJbXCIgKihbRldTXSBkdGV4dCkgW0ZXU10gXCJdXCIgW0NGV1NdXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIGR0ZXh0ICAgICAgICAgICA9ICAgJWQzMy05MCAvICAgICAgICAgidsgUHJpbnRhYmxlIFVTLUFTQ0lJXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICVkOTQtMTI2IC8gICAgICAgICA7ICBjaGFyYWN0ZXJzIG5vdCBpbmNsdWRpbmdcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgb2JzLWR0ZXh0ICAgICAgICAgidsgIFwiW1wiLCBcIl1cIiwgb3IgXCJcXFwiXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIG9icy1kdGV4dCAgICAgICA9ICAgb2JzLU5PLVdTLUNUTCAvIHF1b3RlZC1wYWlyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmQgb2YgZG9tYWluIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4UmVzdWx0idwgaW50ZXJuYWxzLmNhdGVnb3JpZXMuZGVwcmVjYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIGEgdmFsaWQgUkZDidUzMjEgYWRkcmVzcyBsaXRlcmFsLCBzbyBsZXQncyBjaGVja1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuMS4yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhZGRyZXNzLWxpdGVyYWwgid0gXCJbXCIgKCBJUHY0LWFkZHJlc3MtbGl0ZXJhbCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIElQdjYtYWRkcmVzcy1saXRlcmFsIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgR2VuZXJhbC1hZGRyZXNzLWxpdGVyYWwgKSBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICA7IFNlZSBTZWN0aW9uidQuMS4zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC4xLjNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIElQdjQtYWRkcmVzcy1saXRlcmFsICA9IFNudW0gMyhcIi5cIiAgU251bSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgSVB2Ni1hZGRyZXNzLWxpdGVyYWwgid0gXCJJUHY2OlwiIElQdjYtYWRkclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBHZW5lcmFsLWFkZHJlc3MtbGl0ZXJhbCAgPSBTdGFuZGFyZGl6ZWQtdGFnIFwiOlwiidEqZGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgU3RhbmRhcmRpemVkLXRhZyAgPSBMZGgtc3RyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICA7IFN0YW5kYXJkaXplZC10YWcgTVVTVCBiZSBzcGVjaWZpZWQgaW4gYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgOyBTdGFuZGFyZHMtVHJhY2sgUkZDIGFuZCByZWdpc3RlcmVkIHdpdGggSUFOQVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkY29udGVudCAgICAgid0gJWQzMy05MCAvidsgUHJpbnRhYmxlIFVTLUFTQ0lJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICVkOTQtMTI2idsgZXhjbC4gXCJbXCIsIFwiXFxcIiwgXCJdXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgU251bSAgICAgICAgICA9idEqM0RJR0lUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgidsgcmVwcmVzZW50aW5nIGEgZGVjaW1hbCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgidsgdmFsdWUgaW4gdGhlIHJhbmdlidAgdGhyb3VnaCAyNTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgSVB2Ni1hZGRyICAgICA9IElQdjYtZnVsbCAvIElQdjYtY29tcCAvIElQdjZ2NC1mdWxsIC8gSVB2NnY0LWNvbXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgSVB2Ni1oZXggICAgICA9idEqNEhFWERJR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBJUHY2LWZ1bGwgICAgid0gSVB2Ni1oZXggNyhcIjpcIiBJUHY2LWhleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgSVB2Ni1jb21wICAgICA9IFtJUHY2LWhleCAqNShcIjpcIiBJUHY2LWhleCldIFwiOjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBbSVB2Ni1oZXggKjUoXCI6XCIgSVB2Ni1oZXgpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICA7IFRoZSBcIjo6XCIgcmVwcmVzZW50cyBhdCBsZWFzdCAyidE2LWJpdCBncm91cHMgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgOyB6ZXJvcy4gIE5vIG1vcmUgdGhhbiA2IGdyb3VwcyBpbiBhZGRpdGlvbiB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgOyBcIjo6XCIgbWF5IGJlIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIElQdjZ2NC1mdWxsICAgPSBJUHY2LWhleCA1KFwiOlwiIElQdjYtaGV4KSBcIjpcIiBJUHY0LWFkZHJlc3MtbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBJUHY2djQtY29tcCAgid0gW0lQdjYtaGV4ICozKFwiOlwiIElQdjYtaGV4KV0gXCI6OlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIFtJUHY2LWhleCAqMyhcIjpcIiBJUHY2LWhleCkgXCI6XCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIElQdjQtYWRkcmVzcy1saXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgidsgVGhlIFwiOjpcIiByZXByZXNlbnRzIGF0IGxlYXN0idIgMTYtYml0IGdyb3VwcyBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICA7IHplcm9zLiAgTm8gbW9yZSB0aGFuidQgZ3JvdXBzIGluIGFkZGl0aW9uIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICA7IFwiOjpcIiBhbmQgSVB2NC1hZGRyZXNzLWxpdGVyYWwgbWF5IGJlIHByZXNlbnQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkcmVzc0xpdGVyYWwgPSBwYXJzZURhdGEubGl0ZXJhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzSVAgPSBpbnRlcm5hbHMucmVnZXguaXBWNC5leGVjKGFkZHJlc3NMaXRlcmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIGV4dHJhY3QgSVB2NCBwYXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYWRkcmVzcy1saXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNJUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1hdGNoZXNJUC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IElQdjQgcGFydCB0byBJUHY2IGZvcm1hdCBmb3IgZnV0aGVyIHRlc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NMaXRlcmFsid0gYWRkcmVzc0xpdGVyYWwuc2xpY2UoMCwgaW5kZXgpICsgJzA6MCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09idApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0aGVyZSBleGNlcHQgYSB2YWxpZCBJUHY0IGFkZHJlc3MsIHNvLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLnJmYzUzMjFBZGRyZXNzTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZHJlc3NMaXRlcmFsLnNsaWNlKDAsidUpLnRvTG93ZXJDYXNlKCkgIT09ICdpcHY2OicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMkRvbWFpbkxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhZGRyZXNzTGl0ZXJhbC5zbGljZSg1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heEdyb3VwcyA9IGludGVybmFscy5tYXhJUHY2R3JvdXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBncm91cHMgPSBtYXRjaC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4T2YoJzo6Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF+aW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgZXhhY3RseSB0aGUgcmlnaHQgbnVtYmVyIG9mIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggIT09IG1heEdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLnJmYzUzMjJJUHY2R3JvdXBDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggIT09IG1hdGNoLmxhc3RJbmRleE9mKCc6OicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIySVB2NjJ4MnhDb2xvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09idAgfHwgaW5kZXggPT09IG1hdGNoLmxlbmd0aCAtidIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSRkMgNDI5MSBhbGxvd3MgOjogYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhbiBhZGRyZXNzIHdpdGggNyBvdGhlciBncm91cHMgaW4gYWRkaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK21heEdyb3VwcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPiBtYXhHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIySVB2Nk1heEdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChncm91cHMubGVuZ3Roid09PSBtYXhHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGlkaW5nIGEgc2luZ2xlIFwiOjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmRlcHJlY2F0ZWRJUHY2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElQdjYgdGVzdGluZyBzdHJhdGVneVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMF0gPT09ICc6JyAmJiBtYXRjaFsxXSAhPT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIySVB2NkNvbG9uU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoW21hdGNoLmxlbmd0aCAtidFdid09PSAnOicgJiYgbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMl0gIT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMklQdjZDb2xvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJuYWxzLmNoZWNrSXBWNihncm91cHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIxQWRkcmVzc0xpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMklQdjZCYWRDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMkRvbWFpbkxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEuZG9tYWluICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbURhdGEuZG9tYWluc1tlbGVtZW50Q291bnRdICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0b2tlbiwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJldiA9IGNvbnRleHQubm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub3cgPSBjb250ZXh0LnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5yZmM1MzIyRG9tYWluTGl0ZXJhbE9CU0RUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sucHVzaChjb250ZXh0Lm5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRRdW90ZWRQYWlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvbGRpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbWFpbExlbmd0aCA9PT0gKytpIHx8IGVtYWlsW2ldICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckNSTm9MRik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5jZndzRldTKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjay5wdXNoKGNvbnRleHQubm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm93id0gaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dEZXUztcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERURVhUXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy40LjFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZHRleHQgICAgICAgICA9ICAgJWQzMy05MCAvICA7IFByaW50YWJsZSBVUy1BU0NJSVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAlZDk0LTEyNiAvidsgIGNoYXJhY3RlcnMgbm90IGluY2x1ZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBvYnMtZHRleHQgidsgIFwiW1wiLCBcIl1cIiwgb3IgXCJcXFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBvYnMtZHRleHQgICAgid0gICBvYnMtTk8tV1MtQ1RMIC8gcXVvdGVkLXBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIG9icy1OTy1XUy1DVEwgPSAgICVkMS04IC8gICAgOyBVUy1BU0NJSSBjb250cm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICVkMTEgLyAgICAgOyAgY2hhcmFjdGVycyB0aGF0IGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAlZDEyIC8gICAgidsgIGluY2x1ZGUgdGhlIGNhcnJpYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICVkMTQtMzEgLyAgOyAgcmV0dXJuLCBsaW5lIGZlZWQsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAlZDEyNyAgICAgidsgIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2Rlid0gdG9rZW4uY29kZVBvaW50QXQoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHInLCAnXFxuJywgJyAnLCBhbmQgJ1xcdCcgaGF2ZSBhbHJlYWR5IGJlZW4gcGFyc2VkIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNoYXJDb2RlICE9PSAxMjcgJiYgaW50ZXJuYWxzLmMxQ29udHJvbHMoY2hhckNvZGUpKSB8fCBjaGFyQ29kZSA9PT0gMCB8fCB0b2tlbiA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmF0YWwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJFeHBlY3RpbmdEVEVYVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMuYzBDb250cm9scyhjaGFyQ29kZSkgfHwgY2hhckNvZGUgPT09idEyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLnJmYzUzMjJEb21haW5MaXRlcmFsT0JTRFRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEubGl0ZXJhbCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YS5kb21haW4gKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9tRGF0YS5kb21haW5zW2VsZW1lbnRDb3VudF0gKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHRva2VuLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gUXVvdGVkIHN0cmluZ1xuICAgICAgICAgICAgY2FzZSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0UXVvdGVkU3RyaW5nOlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjIuNFxuICAgICAgICAgICAgICAgIC8vICAgcXVvdGVkLXN0cmluZyA9IFtDRldTXVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgIERRVU9URSAqKFtGV1NdIHFjb250ZW50KSBbRldTXSBEUVVPVEVcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICBbQ0ZXU11cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgcWNvbnRlbnQgICAgICA9IHF0ZXh0IC8gcXVvdGVkLXBhaXJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFF1b3RlZCBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjay5wdXNoKGNvbnRleHQubm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm93id0gaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dFF1b3RlZFBhaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sZGluZyB3aGl0ZSBzcGFjZS4gU3BhY2VzIGFyZSBhbGxvd2VkIGFzIHJlZ3VsYXIgY2hhcmFjdGVycyBpbnNpZGUgYSBxdW90ZWQgc3RyaW5nIC0gaXQncyBvbmx5IEZXUyBpZiB3ZSBpbmNsdWRlICdcXHQnIG9yICdcXHJcXG4nXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1haWxMZW5ndGggPT09ICsraSB8fCBlbWFpbFtpXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckNSTm9MRik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjIuMlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBSdW5zIG9mIEZXUywgY29tbWVudCwgb3IgQ0ZXUyB0aGF0IG9jY3VyIGJldHdlZW4gbGV4aWNhbCB0b2tlbnMgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYSBzdHJ1Y3R1cmVkIGhlYWRlciBmaWVsZCBhcmUgc2VtYW50aWNhbGx5IGludGVycHJldGVkIGFzIGEgc2luZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHNwYWNlIGNoYXJhY3Rlci5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMiNzZWN0aW9uLTMuMi40XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHRoZSBDUkxGIGluIGFueSBGV1MvQ0ZXUyB0aGF0IGFwcGVhcnMgd2l0aGluIHRoZSBxdW90ZWQtc3RyaW5nIFtpc11cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgc2VtYW50aWNhbGx5IFwiaW52aXNpYmxlXCIgYW5kIHRoZXJlZm9yZSBub3QgcGFydCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcXVvdGVkLXN0cmluZ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEubG9jYWwgKz0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbURhdGEubG9jYWxzW2VsZW1lbnRDb3VudF0gKz0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0b2tlbiwgJ3V0ZjgnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuY2Z3c0ZXUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLnB1c2goY29udGV4dC5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub3cgPSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0RldTO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlRva2Vuid0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIG9mIHF1b3RlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhLmxvY2FsICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbURhdGEubG9jYWxzW2VsZW1lbnRDb3VudF0gKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHRva2VuLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wcmV2id0gY29udGV4dC5ub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGNvbnRleHQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVRFWFRcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjIuNFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBxdGV4dCAgICAgICAgICA9ICAgJWQzMyAvICAgICAgICAgICAgidsgUHJpbnRhYmxlIFVTLUFTQ0lJXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAlZDM1LTkxIC8gICAgICAgICAgOyAgY2hhcmFjdGVycyBub3QgaW5jbHVkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAlZDkzLTEyNiAvICAgICAgICAgOyAgXCJcXFwiIG9yIHRoZSBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIG9icy1xdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgb2JzLXF0ZXh0ICAgICAgPSAgIG9icy1OTy1XUy1DVExcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIG9icy1OTy1XUy1DVEwgid0gICAlZDEtOCAvICAgICAgICAgICAgOyBVUy1BU0NJSSBjb250cm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAlZDExIC8gICAgICAgICAgICAgOyAgY2hhcmFjdGVycyB0aGF0IGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgJWQxMiAvICAgICAgICAgICAgidsgIGluY2x1ZGUgdGhlIGNhcnJpYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAlZDE0LTMxIC8gICAgICAgICAgOyAgcmV0dXJuLCBsaW5lIGZlZWQsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgJWQxMjcgICAgICAgICAgICAgidsgIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2Rlid0gdG9rZW4uY29kZVBvaW50QXQoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2hhckNvZGUgIT09idEyNyAmJiBpbnRlcm5hbHMuYzFDb250cm9scyhjaGFyQ29kZSkpIHx8IGNoYXJDb2Rlid09PSAwIHx8IGNoYXJDb2Rlid09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckV4cGVjdGluZ1FURVhUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGludGVybmFscy5jMENvbnRyb2xzKGNoYXJDb2RlKSB8fCBjaGFyQ29kZSA9PT0gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZGVwcmVjYXRlZFFURVhUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhLmxvY2FsICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbURhdGEubG9jYWxzW2VsZW1lbnRDb3VudF0gKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHRva2VuLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjIjc2VjdGlvbi0zLjQuMVxuICAgICAgICAgICAgICAgIC8vICAgSWYgdGhlIHN0cmluZyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBkb3QtYXRvbSAodGhhdCBpcywgaXQgY29udGFpbnNcbiAgICAgICAgICAgICAgICAvLyAgIG5vIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBhdGV4dCBjaGFyYWN0ZXJzIG9yIFwiLlwiIHN1cnJvdW5kZWQgYnkgYXRleHRcbiAgICAgICAgICAgICAgICAvLyAgIGNoYXJhY3RlcnMpLCB0aGVuIHRoZSBkb3QtYXRvbSBmb3JtIFNIT1VMRCBiZSB1c2VkIGFuZCB0aGUgcXVvdGVkLVxuICAgICAgICAgICAgICAgIC8vICAgc3RyaW5nIGZvcm0gU0hPVUxEIE5PVCBiZSB1c2VkLlxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gUXVvdGVkIHBhaXJcbiAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dFF1b3RlZFBhaXI6XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMiNzZWN0aW9uLTMuMi4xXG4gICAgICAgICAgICAgICAgLy8gICBxdW90ZWQtcGFpciAgICAgPSAgIChcIlxcXCIgKFZDSEFSIC8gV1NQKSkgLyBvYnMtcXBcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgVkNIQVIgICAgICAgICAgid0gICVkMzMtMTI2ICAgOyB2aXNpYmxlIChwcmludGluZykgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIC8vICAgV1NQICAgICAgICAgICAgid0gIFNQIC8gSFRBQiAgOyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBvYnMtcXAgICAgICAgICAgPSAgIFwiXFxcIiAoJWQwIC8gb2JzLU5PLVdTLUNUTCAvIExGIC8gQ1IpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIG9icy1OTy1XUy1DVEwgICA9ICAgJWQxLTggLyAgidsgVVMtQVNDSUkgY29udHJvbFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAlZDExIC8gICAgOyAgY2hhcmFjdGVycyB0aGF0IGRvIG5vdFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAlZDEyIC8gICAgOyAgaW5jbHVkZSB0aGUgY2FycmlhZ2VcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgJWQxNC0zMSAvidsgIHJldHVybiwgbGluZSBmZWVkLCBhbmRcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgJWQxMjcgICAgidsgIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGkuZS4gb2JzLXFwICAgICAgid0gIFwiXFxcIiAoJWQwLTgsICVkMTAtMzEgLyAlZDEyNylcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHRva2VuLmNvZGVQb2ludEF0KDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlICE9PSAxMjcgJiYgIGludGVybmFscy5jMUNvbnRyb2xzKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJFeHBlY3RpbmdRUGFpcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjaGFyQ29kZSA8idMxICYmIGNoYXJDb2RlICE9PSA5KSB8fCBjaGFyQ29kZSA9PT0gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICcgJyBhbmQgJ1xcdCcgYXJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZGVwcmVjYXRlZFFQKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgd2hlcmUgdGhpcyBxcGFpciBvY2N1cnJlZCBzbyB3ZSBjb3VsZCBjaGVjayB0byBzZWUgaWYgdGhlIGNoYXJhY3RlciBhY3R1YWxseSBuZWVkZWQgdG8gYmUgcXVvdGVkIGF0IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC4xLjJcbiAgICAgICAgICAgICAgICAvLyAgIHRoZSBzZW5kaW5nIHN5c3RlbSBTSE9VTEQgdHJhbnNtaXQgdGhlIGZvcm0gdGhhdCB1c2VzIHRoZSBtaW5pbXVtIHF1b3RpbmcgcG9zc2libGUuXG5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnByZXYgPSBjb250ZXh0Lm5vdztcbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgcXBhaXJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGNvbnRleHQuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlVG9rZW4gPSAnXFxcXCcgKyB0b2tlbjtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29udGV4dC5ub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0Q29tbWVudDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dFF1b3RlZFN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YS5sb2NhbCArPSBlc2NhcGVUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0b21EYXRhLmxvY2Fsc1tlbGVtZW50Q291bnRdICs9IGVzY2FwZVRva2VuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBzaXplcyBzcGVjaWZpZWQgYnkgUkZDidUzMjEgYXJlIG9jdGV0IGNvdW50cywgc28gd2UgbXVzdCBpbmNsdWRlIHRoZSBiYWNrc2xhc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRMZW5ndGggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMubGl0ZXJhbDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YS5kb21haW4gKz0gZXNjYXBlVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9tRGF0YS5kb21haW5zW2VsZW1lbnRDb3VudF0gKz0gZXNjYXBlVG9rZW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIHNpemVzIHNwZWNpZmllZCBieSBSRkMgNTMyMSBhcmUgb2N0ZXQgY291bnRzLCBzbyB3ZSBtdXN0IGluY2x1ZGUgdGhlIGJhY2tzbGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6b2ZmJFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxdW90ZWQgcGFpciBsb2dpYyBpbnZva2VkIGluIGFuIGludmFsaWQgY29udGV4dDogJyArIGNvbnRleHQubm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6b24kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tbWVudFxuICAgICAgICAgICAgY2FzZSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0Q29tbWVudDpcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy4yLjJcbiAgICAgICAgICAgICAgICAvLyAgIGNvbW1lbnQgid0gXCIoXCIgKihbRldTXSBjY29udGVudCkgW0ZXU10gXCIpXCJcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICAgY2NvbnRlbnQgPSBjdGV4dCAvIHF1b3RlZC1wYWlyIC8gY29tbWVudFxuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVzdGVkIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgY29tbWVudHMgYXJlIG9rXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLnB1c2goY29udGV4dC5ub3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub3cgPSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0Q29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgb2YgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJldiA9IGNvbnRleHQubm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub3cgPSBjb250ZXh0LnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1b3RlZCBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGFjay5wdXNoKGNvbnRleHQubm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm93id0gaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dFF1b3RlZFBhaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sZGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtYWlsTGVuZ3Roid09PSArK2kgfHwgZW1haWxbaV0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmF0YWwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJDUk5vTEYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsdGhyb3VnaFxuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuY2Z3c0ZXUyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhY2sucHVzaChjb250ZXh0Lm5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vdyA9IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRGV1M7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDVEVYVFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMiNzZWN0aW9uLTMuMi4zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN0ZXh0ICAgICAgICAgPSAlZDMzLTM5IC8gidsgUHJpbnRhYmxlIFVTLUFTQ0lJXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAlZDQyLTkxIC8gidsgIGNoYXJhY3RlcnMgbm90IGluY2x1ZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgJWQ5My0xMjYgLyA7ICBcIihcIiwgXCIpXCIsIG9yIFwiXFxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgb2JzLWN0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBvYnMtY3RleHQgICAgid0gb2JzLU5PLVdTLUNUTFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgb2JzLU5PLVdTLUNUTCA9ICVkMS04IC8gICAgOyBVUy1BU0NJSSBjb250cm9sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAlZDExIC8gICAgidsgIGNoYXJhY3RlcnMgdGhhdCBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICVkMTIgLyAgICAgOyAgaW5jbHVkZSB0aGUgY2FycmlhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICVkMTQtMzEgLyAgOyAgcmV0dXJuLCBsaW5lIGZlZWQsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgJWQxMjcgICAgICA7ICB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHRva2VuLmNvZGVQb2ludEF0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09idAgfHwgY2hhckNvZGUgPT09idEwIHx8IChjaGFyQ29kZSAhPT0gMTI3ICYmIGludGVybmFscy5jMUNvbnRyb2xzKGNoYXJDb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYXRhbCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckV4cGVjdGluZ0NURVhUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGludGVybmFscy5jMENvbnRyb2xzKGNoYXJDb2RlKSB8fCBjaGFyQ29kZSA9PT0gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZGVwcmVjYXRlZENURVhUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8vIEZvbGRpbmcgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgIGNhc2UgaW50ZXJuYWxzLmNvbXBvbmVudHMuY29udGV4dEZXUzpcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIyI3NlY3Rpb24tMy4yLjJcbiAgICAgICAgICAgICAgICAvLyAgIEZXUyAgICAgPSAgIChbKldTUCBDUkxGXSAxKldTUCkgLyAgb2JzLUZXU1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IEZvbGRpbmcgd2hpdGUgc3BhY2VcblxuICAgICAgICAgICAgICAgIC8vIEJ1dCBub3RlIHRoZSBlcnJhdHVtOlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cucmZjLWVkaXRvci5vcmcvZXJyYXRhX3NlYXJjaC5waHA/cmZjPTUzMjImZWlkPTE5MDg6XG4gICAgICAgICAgICAgICAgLy8gICBJbiB0aGUgb2Jzb2xldGUgc3ludGF4LCBhbnkgYW1vdW50IG9mIGZvbGRpbmcgd2hpdGUgc3BhY2UgTUFZIGJlXG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRlZCB3aGVyZSB0aGUgb2JzLUZXUyBydWxlIGlzIGFsbG93ZWQuICBUaGlzIGNyZWF0ZXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBwb3NzaWJpbGl0eSBvZiBoYXZpbmcgdHdvIGNvbnNlY3V0aXZlIFwiZm9sZHNcIiBpbiBhIGxpbmUsIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgdGhlcmVmb3JlIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGEgbGluZSB3aGljaCBtYWtlcyB1cCBhIGZvbGRlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAvLyAgIGZpZWxkIGNvdWxkIGJlIGNvbXBvc2VkIGVudGlyZWx5IG9mIHdoaXRlIHNwYWNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gICBvYnMtRldTid0gICAxKihbQ1JMRl0gV1NQKVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUb2tlbiA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuid09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmF0YWwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckZXU0NSTEZ4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NybGZDb3VudCA+idEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIGZvbGRzid0+IG9ic29sZXRlIEZXU1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZGVwcmVjYXRlZEZXUyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmxmQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtYWlsTGVuZ3Roid09PSArK2kgfHwgZW1haWxbaV0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmF0YWwgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJDUk5vTEYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2Vuid09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhdGFsIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZXJyRldTQ1JMRkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNybGZDb3VudCA9idA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBvZiBGV1NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJldiA9IGNvbnRleHQubm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub3cgPSBjb250ZXh0LnN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGF0IHRoaXMgdG9rZW4gYWdhaW4gaW4gdGhlIHBhcmVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldlRva2Vuid0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOm9mZiRcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbnRleHQ6ICcgKyBjb250ZXh0Lm5vdyk7XG4gICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTpvbiRcbiAgICAgICAgfSAvLyBQcmltYXJ5IHN0YXRlIG1hY2hpbmVcblxuICAgICAgICBpZiAobWF4UmVzdWx0id4gaW50ZXJuYWxzLmNhdGVnb3JpZXMucmZjNTMyMikge1xuICAgICAgICAgICAgLy8gRmF0YWwgZXJyb3IsIG5vIHBvaW50IGNvbnRpbnVpbmdcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSAvLyBUb2tlbiBsb29wXG5cbiAgICAvLyBDaGVjayBmb3IgZXJyb3JzXG4gICAgaWYgKG1heFJlc3VsdCA8IGludGVybmFscy5jYXRlZ29yaWVzLnJmYzUzMjIpIHtcbiAgICAgICAgY29uc3QgcHVueWNvZGVMZW5ndGggPSBQdW55Y29kZS5lbmNvZGUocGFyc2VEYXRhLmRvbWFpbikubGVuZ3RoO1xuICAgICAgICAvLyBGYXRhbCBlcnJvcnNcbiAgICAgICAgaWYgKGNvbnRleHQubm93id09PSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0UXVvdGVkU3RyaW5nKSB7XG4gICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJVbmNsb3NlZFF1b3RlZFN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5ub3cgPT09IGludGVybmFscy5jb21wb25lbnRzLmNvbnRleHRRdW90ZWRQYWlyKSB7XG4gICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJCYWNrc2xhc2hFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHQubm93id09PSBpbnRlcm5hbHMuY29tcG9uZW50cy5jb250ZXh0Q29tbWVudCkge1xuICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZXJyVW5jbG9zZWRDb21tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0Lm5vdyA9PT0gaW50ZXJuYWxzLmNvbXBvbmVudHMubGl0ZXJhbCkge1xuICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZXJyVW5jbG9zZWREb21haW5MaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLmVyckZXU0NSTEZFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlRGF0YS5kb21haW4ubGVuZ3Roid09PSAwKSB7XG4gICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJOb0RvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZXJyRG90RW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoeXBoZW5GbGFnKSB7XG4gICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJEb21haW5IeXBoZW5FbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXIgZXJyb3JzXG4gICAgICAgIGVsc2UgaWYgKHB1bnljb2RlTGVuZ3Roid4gMjU1KSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4yXG4gICAgICAgICAgICAvLyAgIFRoZSBtYXhpbXVtIHRvdGFsIGxlbmd0aCBvZiBhIGRvbWFpbiBuYW1lIG9yIG51bWJlciBpcyAyNTUgb2N0ZXRzLlxuICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMucmZjNTMyMkRvbWFpblRvb0xvbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBhcnNlRGF0YS5sb2NhbCwgJ3V0ZjgnKSArIHB1bnljb2RlTGVuZ3RoICsgLyogJ0AnICovidEgPiAyNTQpIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjEjc2VjdGlvbi00LjEuMlxuICAgICAgICAgICAgLy8gICBGb3J3YXJkLXBhdGggICA9IFBhdGhcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIFBhdGggICAgICAgICAgid0gXCI8XCIgWyBBLWQtbCBcIjpcIiBdIE1haWxib3ggXCI+XCJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4zXG4gICAgICAgICAgICAvLyAgIFRoZSBtYXhpbXVtIHRvdGFsIGxlbmd0aCBvZiBhIHJldmVyc2UtcGF0aCBvciBmb3J3YXJkLXBhdGggaXMgMjU2IG9jdGV0cyAoaW5jbHVkaW5nIHRoZSBwdW5jdHVhdGlvbiBhbmQgZWxlbWVudCBzZXBhcmF0b3JzKS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaHVzLCBldmVuIHdpdGhvdXQgKG9ic29sZXRlKSByb3V0aW5nIGluZm9ybWF0aW9uLCB0aGUgTWFpbGJveCBjYW4gb25seSBiZSAyNTQgY2hhcmFjdGVycyBsb25nLiBUaGlzIGlzIGNvbmZpcm1lZCBieSB0aGlzIHZlcmlmaWVkXG4gICAgICAgICAgICAvLyBlcnJhdHVtIHRvIFJGQyAzNjk2OlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cucmZjLWVkaXRvci5vcmcvZXJyYXRhX3NlYXJjaC5waHA/cmZjPTM2OTYmZWlkPTE2OTBcbiAgICAgICAgICAgIC8vICAgSG93ZXZlciwgdGhlcmUgaXMgYSByZXN0cmljdGlvbiBpbiBSRkMgMjgyMSBvbiB0aGUgbGVuZ3RoIG9mIGFuIGFkZHJlc3MgaW4gTUFJTCBhbmQgUkNQVCBjb21tYW5kcyBvZiAyNTQgY2hhcmFjdGVycy4gIFNpbmNlXG4gICAgICAgICAgICAvLyAgIGFkZHJlc3NlcyB0aGF0IGRvIG5vdCBmaXQgaW4gdGhvc2UgZmllbGRzIGFyZSBub3Qgbm9ybWFsbHkgdXNlZnVsLCB0aGUgdXBwZXIgbGltaXQgb24gYWRkcmVzcyBsZW5ndGhzIHNob3VsZCBub3JtYWxseSBiZSBjb25zaWRlcmVkXG4gICAgICAgICAgICAvLyAgIHRvIGJlidI1NC5cbiAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLnJmYzUzMjJUb29Mb25nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50TGVuZ3Roid4gNjMpIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzUjc2VjdGlvbi0yLjMuNFxuICAgICAgICAgICAgLy8gbGFiZWxzICAgNjMgb2N0ZXRzIG9yIGxlc3NcbiAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLnJmYzUzMjJMYWJlbFRvb0xvbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMubWluRG9tYWluQXRvbXMgJiYgYXRvbURhdGEuZG9tYWlucy5sZW5ndGggPCBvcHRpb25zLm1pbkRvbWFpbkF0b21zKSB7XG4gICAgICAgICAgICB1cGRhdGVSZXN1bHQoaW50ZXJuYWxzLmRpYWdub3Nlcy5lcnJEb21haW5Ub29TaG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50bGRXaGl0ZWxpc3QgfHwgb3B0aW9ucy50bGRCbGFja2xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHRsZEF0b20gPSBhdG9tRGF0YS5kb21haW5zW2VsZW1lbnRDb3VudF07XG5cbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnZhbGlkRG9tYWluKHRsZEF0b20sIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KGludGVybmFscy5kaWFnbm9zZXMuZXJyVW5rbm93blRMRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIENoZWNrIGZvciBlcnJvcnNcblxuICAgIC8vIEZpbmlzaFxuICAgIGlmIChtYXhSZXN1bHQgPCBpbnRlcm5hbHMuY2F0ZWdvcmllcy5kbnNXYXJuKSB7XG4gICAgICAgIC8vIFBlciBSRkMgNTMyMSwgZG9tYWluIGF0b21zIGFyZSBsaW1pdGVkIHRvIGxldHRlci1kaWdpdC1oeXBoZW4sIHNvIHdlIG9ubHkgbmVlZCB0byBjaGVjayBjb2Rlidw9idU3IHRvIGNoZWNrIGZvciBhIGRpZ2l0XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhdG9tRGF0YS5kb21haW5zW2VsZW1lbnRDb3VudF0uY29kZVBvaW50QXQoMCk7XG5cbiAgICAgICAgaWYgKGNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChpbnRlcm5hbHMuZGlhZ25vc2VzLnJmYzUzMjFUTEROdW1lcmljKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhSZXN1bHQgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgbWF4UmVzdWx0id0gaW50ZXJuYWxzLmRpYWdub3Nlcy52YWxpZDtcbiAgICB9XG5cbiAgICBjb25zdCBmaW5pc2hSZXN1bHQgPSBkaWFnbm9zZSA/IG1heFJlc3VsdCA6IG1heFJlc3VsdCA8IGludGVybmFscy5kZWZhdWx0VGhyZXNob2xkO1xuXG4gICAgLy8gJGxhYjpjb3ZlcmFnZTpvZmYkXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGZpbmlzaFJlc3VsdCk7XG4gICAgfVxuICAgIC8vICRsYWI6Y292ZXJhZ2U6b24kXG5cbiAgICByZXR1cm4gZmluaXNoUmVzdWx0O1xufTtcblxuXG5leHBvcnRzLmRpYWdub3NlcyA9IGludGVybmFscy52YWxpZGF0ZS5kaWFnbm9zZXMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgZGlhZyA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnRlcm5hbHMuZGlhZ25vc2VzKTtcbiAgICBmb3IgKGxldCBpid0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5id0ga2V5c1tpXTtcbiAgICAgICAgZGlhZ1trZXldid0gaW50ZXJuYWxzLmRpYWdub3Nlc1trZXldO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFnO1xufSkoKTtcblxuXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGludGVybmFscy5ub3JtYWxpemU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/isemail/lib/index.js\n");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcz8xOTg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzid09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsid0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93id09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmid09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkidMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuidB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlid0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4id0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9idcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vidB4ODBcblx0ZGVsaW1pdGVyid0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzid0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0id0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkid0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0id0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlid0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhid0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmidB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpidw8idEwKSArIChleHRyYSAmidB4M0ZGKSAridB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+idB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlid4+PiAxMCAmidB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmidB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtidFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtidQ4idwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtidY1idwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtidk3idwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vidI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCAridIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uidMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrid0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4id4+idE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0id0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3Roid0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuid0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8idApIHtcblx0XHRcdGJhc2ljid0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqidwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljid4gMCA/IGJhc2ljICsgMSA6idA7IGluZGV4idwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpid0gaSwgdyA9idEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0idwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0id0gb3V0cHV0Lmxlbmd0aCAridE7XG5cdFx0XHRiaWFzid0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0id0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0id0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9idA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9idA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3Roid0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50idwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9idA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlid49IG4gJiYgY3VycmVudFZhbHVlidwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzidxuLGk+IHN0YXRlIHRvidxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9idA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxid0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUid0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUid0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsidApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kid09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzid0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldid0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2Rlid0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsVUFhQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/node-libs-browser/node_modules/punycode/punycode.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ })

}]);